// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/exchange/v1beta1/exchange.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// order types
type SpotLimitOrder_LimitOrderType int32

const (
	SpotLimitOrder_LIMIT SpotLimitOrder_LimitOrderType = 0
	SpotLimitOrder_STOP  SpotLimitOrder_LimitOrderType = 1
	SpotLimitOrder_TAKE  SpotLimitOrder_LimitOrderType = 2
)

var SpotLimitOrder_LimitOrderType_name = map[int32]string{
	0: "LIMIT",
	1: "STOP",
	2: "TAKE",
}

var SpotLimitOrder_LimitOrderType_value = map[string]int32{
	"LIMIT": 0,
	"STOP":  1,
	"TAKE":  2,
}

func (x SpotLimitOrder_LimitOrderType) String() string {
	return proto.EnumName(SpotLimitOrder_LimitOrderType_name, int32(x))
}

func (SpotLimitOrder_LimitOrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{2, 0}
}

// order types
type SpotMarketOrder_MarketOrderType int32

const (
	SpotMarketOrder_MARKET SpotMarketOrder_MarketOrderType = 0
	SpotMarketOrder_STOP   SpotMarketOrder_MarketOrderType = 1
	SpotMarketOrder_TAKE   SpotMarketOrder_MarketOrderType = 2
)

var SpotMarketOrder_MarketOrderType_name = map[int32]string{
	0: "MARKET",
	1: "STOP",
	2: "TAKE",
}

var SpotMarketOrder_MarketOrderType_value = map[string]int32{
	"MARKET": 0,
	"STOP":   1,
	"TAKE":   2,
}

func (x SpotMarketOrder_MarketOrderType) String() string {
	return proto.EnumName(SpotMarketOrder_MarketOrderType_name, int32(x))
}

func (SpotMarketOrder_MarketOrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{3, 0}
}

// order types
type BaseSpotOrder_OrderType int32

const (
	BaseSpotOrder_LIMIT_BUY        BaseSpotOrder_OrderType = 0
	BaseSpotOrder_LIMIT_SELL       BaseSpotOrder_OrderType = 1
	BaseSpotOrder_MARKET_BUY       BaseSpotOrder_OrderType = 2
	BaseSpotOrder_MARKET_SELL      BaseSpotOrder_OrderType = 3
	BaseSpotOrder_STOP_LIMIT_BUY   BaseSpotOrder_OrderType = 4
	BaseSpotOrder_STOP_LIMIT_SELL  BaseSpotOrder_OrderType = 5
	BaseSpotOrder_STOP_MARKET_BUY  BaseSpotOrder_OrderType = 6
	BaseSpotOrder_STOP_MARKET_SELL BaseSpotOrder_OrderType = 7
	BaseSpotOrder_TAKE_LIMIT_BUY   BaseSpotOrder_OrderType = 8
	BaseSpotOrder_TAKE_LIMIT_SELL  BaseSpotOrder_OrderType = 9
	BaseSpotOrder_TAKE_MARKET_BUY  BaseSpotOrder_OrderType = 10
	BaseSpotOrder_TAKE_MARKET_SELL BaseSpotOrder_OrderType = 11
)

var BaseSpotOrder_OrderType_name = map[int32]string{
	0:  "LIMIT_BUY",
	1:  "LIMIT_SELL",
	2:  "MARKET_BUY",
	3:  "MARKET_SELL",
	4:  "STOP_LIMIT_BUY",
	5:  "STOP_LIMIT_SELL",
	6:  "STOP_MARKET_BUY",
	7:  "STOP_MARKET_SELL",
	8:  "TAKE_LIMIT_BUY",
	9:  "TAKE_LIMIT_SELL",
	10: "TAKE_MARKET_BUY",
	11: "TAKE_MARKET_SELL",
}

var BaseSpotOrder_OrderType_value = map[string]int32{
	"LIMIT_BUY":        0,
	"LIMIT_SELL":       1,
	"MARKET_BUY":       2,
	"MARKET_SELL":      3,
	"STOP_LIMIT_BUY":   4,
	"STOP_LIMIT_SELL":  5,
	"STOP_MARKET_BUY":  6,
	"STOP_MARKET_SELL": 7,
	"TAKE_LIMIT_BUY":   8,
	"TAKE_LIMIT_SELL":  9,
	"TAKE_MARKET_BUY":  10,
	"TAKE_MARKET_SELL": 11,
}

func (x BaseSpotOrder_OrderType) String() string {
	return proto.EnumName(BaseSpotOrder_OrderType_name, int32(x))
}

func (BaseSpotOrder_OrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{4, 0}
}

// An object describing a derivative market in the Injective Futures Protocol.
type DerivativeMarket struct {
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Address of the oracle for the derivative contract
	Oracle string `protobuf:"bytes,2,opt,name=oracle,proto3" json:"oracle,omitempty"`
	// Address of the base currency for the derivative contract
	BaseCurrency string `protobuf:"bytes,3,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	// Random number to faciltate uniqueness of the derivative market ID
	Nonce string `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,7,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	// price factor
	PriceFactor string `protobuf:"bytes,8,opt,name=price_factor,json=priceFactor,proto3" json:"price_factor,omitempty"`
	// index price
	IndexPrice string `protobuf:"bytes,9,opt,name=index_price,json=indexPrice,proto3" json:"index_price,omitempty"`
	// InitialMarginRatioPermyriad
	InitialMarginRatio string `protobuf:"bytes,10,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3" json:"initial_margin_ratio,omitempty"`
	// MaintenanceMarginRatioPermyriad
	MaintenanceMarginRatio string `protobuf:"bytes,11,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3" json:"maintenance_margin_ratio,omitempty"`
	// MakerTxFeePermyriad
	MakerTxFee string `protobuf:"bytes,12,opt,name=maker_tx_fee,json=makerTxFee,proto3" json:"maker_tx_fee,omitempty"`
	// TakerTxFeePermyriad
	TakerTxFee string `protobuf:"bytes,13,opt,name=taker_tx_fee,json=takerTxFee,proto3" json:"taker_tx_fee,omitempty"`
	// NextFundingTimestamp in seconds
	NextFundingTimestamp string `protobuf:"bytes,14,opt,name=next_funding_timestamp,json=nextFundingTimestamp,proto3" json:"next_funding_timestamp,omitempty"`
	// FundingInterval in seconds
	FundingInterval string `protobuf:"bytes,15,opt,name=funding_interval,json=fundingInterval,proto3" json:"funding_interval,omitempty"`
	// Cumulative Funding in seconds
	CumulativeFunding string `protobuf:"bytes,16,opt,name=cumulative_funding,json=cumulativeFunding,proto3" json:"cumulative_funding,omitempty"`
}

func (m *DerivativeMarket) Reset()         { *m = DerivativeMarket{} }
func (m *DerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarket) ProtoMessage()    {}
func (*DerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{0}
}
func (m *DerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarket.Merge(m, src)
}
func (m *DerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarket proto.InternalMessageInfo

func (m *DerivativeMarket) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *DerivativeMarket) GetOracle() string {
	if m != nil {
		return m.Oracle
	}
	return ""
}

func (m *DerivativeMarket) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *DerivativeMarket) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *DerivativeMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeMarket) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *DerivativeMarket) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *DerivativeMarket) GetPriceFactor() string {
	if m != nil {
		return m.PriceFactor
	}
	return ""
}

func (m *DerivativeMarket) GetIndexPrice() string {
	if m != nil {
		return m.IndexPrice
	}
	return ""
}

func (m *DerivativeMarket) GetInitialMarginRatio() string {
	if m != nil {
		return m.InitialMarginRatio
	}
	return ""
}

func (m *DerivativeMarket) GetMaintenanceMarginRatio() string {
	if m != nil {
		return m.MaintenanceMarginRatio
	}
	return ""
}

func (m *DerivativeMarket) GetMakerTxFee() string {
	if m != nil {
		return m.MakerTxFee
	}
	return ""
}

func (m *DerivativeMarket) GetTakerTxFee() string {
	if m != nil {
		return m.TakerTxFee
	}
	return ""
}

func (m *DerivativeMarket) GetNextFundingTimestamp() string {
	if m != nil {
		return m.NextFundingTimestamp
	}
	return ""
}

func (m *DerivativeMarket) GetFundingInterval() string {
	if m != nil {
		return m.FundingInterval
	}
	return ""
}

func (m *DerivativeMarket) GetCumulativeFunding() string {
	if m != nil {
		return m.CumulativeFunding
	}
	return ""
}

// An object describing trade pair of two assets.
type SpotMarket struct {
	// A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote asset.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Address of the base asset.
	BaseAsset string `protobuf:"bytes,2,opt,name=base_asset,json=baseAsset,proto3" json:"base_asset,omitempty"`
	// Address of the quote asset.
	QuoteAsset string `protobuf:"bytes,3,opt,name=quote_asset,json=quoteAsset,proto3" json:"quote_asset,omitempty"`
	// MakerTxFeePermyriad
	MakerTxFee string `protobuf:"bytes,4,opt,name=maker_tx_fee,json=makerTxFee,proto3" json:"maker_tx_fee,omitempty"`
	// TakerTxFeePermyriad
	TakerTxFee string `protobuf:"bytes,5,opt,name=taker_tx_fee,json=takerTxFee,proto3" json:"taker_tx_fee,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,6,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// If false, then the market is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,7,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,8,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
}

func (m *SpotMarket) Reset()         { *m = SpotMarket{} }
func (m *SpotMarket) String() string { return proto.CompactTextString(m) }
func (*SpotMarket) ProtoMessage()    {}
func (*SpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{1}
}
func (m *SpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarket.Merge(m, src)
}
func (m *SpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarket proto.InternalMessageInfo

func (m *SpotMarket) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *SpotMarket) GetBaseAsset() string {
	if m != nil {
		return m.BaseAsset
	}
	return ""
}

func (m *SpotMarket) GetQuoteAsset() string {
	if m != nil {
		return m.QuoteAsset
	}
	return ""
}

func (m *SpotMarket) GetMakerTxFee() string {
	if m != nil {
		return m.MakerTxFee
	}
	return ""
}

func (m *SpotMarket) GetTakerTxFee() string {
	if m != nil {
		return m.TakerTxFee
	}
	return ""
}

func (m *SpotMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *SpotMarket) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *SpotMarket) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

// A valid signed Spot limit order with Metadata.
type SpotLimitOrder struct {
	// Address that created the order (for make orders, 0x0 for take orders)
	SubaccountID string `protobuf:"bytes,1,opt,name=subaccountID,proto3" json:"subaccountID,omitempty"`
	// Optional address that can cancel order on behalf of maker
	Sender string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipient string `protobuf:"bytes,3,opt,name=feeRecipient,proto3" json:"feeRecipient,omitempty"`
	// timestamp the order expires in unix seconds
	Expiry uint64 `protobuf:"varint,4,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// The amount of the asset supplied
	SupplyAmount string `protobuf:"bytes,5,opt,name=supplyAmount,proto3" json:"supplyAmount,omitempty"`
	// The amount of the asset demanded
	DemandAmount string `protobuf:"bytes,6,opt,name=demandAmount,proto3" json:"demandAmount,omitempty"`
	// the amount of the demand filled
	FilledAmount        string                        `protobuf:"bytes,7,opt,name=filledAmount,proto3" json:"filledAmount,omitempty"`
	CreationBlockHeight int64                         `protobuf:"varint,8,opt,name=creation_block_height,json=creationBlockHeight,proto3" json:"creation_block_height,omitempty"`
	OrderType           SpotLimitOrder_LimitOrderType `protobuf:"varint,9,opt,name=orderType,proto3,enum=injective.exchange.v1beta1.SpotLimitOrder_LimitOrderType" json:"orderType,omitempty"`
	TriggerPrice        string                        `protobuf:"bytes,10,opt,name=triggerPrice,proto3" json:"triggerPrice,omitempty"`
}

func (m *SpotLimitOrder) Reset()         { *m = SpotLimitOrder{} }
func (m *SpotLimitOrder) String() string { return proto.CompactTextString(m) }
func (*SpotLimitOrder) ProtoMessage()    {}
func (*SpotLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{2}
}
func (m *SpotLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotLimitOrder.Merge(m, src)
}
func (m *SpotLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *SpotLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SpotLimitOrder proto.InternalMessageInfo

func (m *SpotLimitOrder) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

func (m *SpotLimitOrder) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *SpotLimitOrder) GetFeeRecipient() string {
	if m != nil {
		return m.FeeRecipient
	}
	return ""
}

func (m *SpotLimitOrder) GetExpiry() uint64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *SpotLimitOrder) GetSupplyAmount() string {
	if m != nil {
		return m.SupplyAmount
	}
	return ""
}

func (m *SpotLimitOrder) GetDemandAmount() string {
	if m != nil {
		return m.DemandAmount
	}
	return ""
}

func (m *SpotLimitOrder) GetFilledAmount() string {
	if m != nil {
		return m.FilledAmount
	}
	return ""
}

func (m *SpotLimitOrder) GetCreationBlockHeight() int64 {
	if m != nil {
		return m.CreationBlockHeight
	}
	return 0
}

func (m *SpotLimitOrder) GetOrderType() SpotLimitOrder_LimitOrderType {
	if m != nil {
		return m.OrderType
	}
	return SpotLimitOrder_LIMIT
}

func (m *SpotLimitOrder) GetTriggerPrice() string {
	if m != nil {
		return m.TriggerPrice
	}
	return ""
}

// A valid signed Spot market order with Metadata.
type SpotMarketOrder struct {
	// Address that created the order (for make orders, 0x0 for take orders)
	SubaccountID string `protobuf:"bytes,1,opt,name=subaccountID,proto3" json:"subaccountID,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipient string `protobuf:"bytes,2,opt,name=feeRecipient,proto3" json:"feeRecipient,omitempty"`
	// The desired quantity of asset to receive
	Quantity string `protobuf:"bytes,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The amount of maximum funds supplied for the trade
	FundsSupplied string                          `protobuf:"bytes,4,opt,name=fundsSupplied,proto3" json:"fundsSupplied,omitempty"`
	OrderType     SpotMarketOrder_MarketOrderType `protobuf:"varint,5,opt,name=orderType,proto3,enum=injective.exchange.v1beta1.SpotMarketOrder_MarketOrderType" json:"orderType,omitempty"`
	TriggerPrice  string                          `protobuf:"bytes,6,opt,name=triggerPrice,proto3" json:"triggerPrice,omitempty"`
}

func (m *SpotMarketOrder) Reset()         { *m = SpotMarketOrder{} }
func (m *SpotMarketOrder) String() string { return proto.CompactTextString(m) }
func (*SpotMarketOrder) ProtoMessage()    {}
func (*SpotMarketOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{3}
}
func (m *SpotMarketOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarketOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarketOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarketOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarketOrder.Merge(m, src)
}
func (m *SpotMarketOrder) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarketOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarketOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarketOrder proto.InternalMessageInfo

func (m *SpotMarketOrder) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

func (m *SpotMarketOrder) GetFeeRecipient() string {
	if m != nil {
		return m.FeeRecipient
	}
	return ""
}

func (m *SpotMarketOrder) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *SpotMarketOrder) GetFundsSupplied() string {
	if m != nil {
		return m.FundsSupplied
	}
	return ""
}

func (m *SpotMarketOrder) GetOrderType() SpotMarketOrder_MarketOrderType {
	if m != nil {
		return m.OrderType
	}
	return SpotMarketOrder_MARKET
}

func (m *SpotMarketOrder) GetTriggerPrice() string {
	if m != nil {
		return m.TriggerPrice
	}
	return ""
}

type BaseSpotOrder struct {
	// Specify chain ID.
	ChainId int64 `protobuf:"zigzag64,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Address that created the order (for make orders, 0x0 for take orders)
	SubaccountID string `protobuf:"bytes,2,opt,name=subaccountID,proto3" json:"subaccountID,omitempty"`
	// Optional address that can cancel order on behalf of maker
	Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipient string `protobuf:"bytes,4,opt,name=feeRecipient,proto3" json:"feeRecipient,omitempty"`
	// timestamp the order expires in unix seconds
	Expiry uint64 `protobuf:"varint,5,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// unique ID of the market
	MarketID string `protobuf:"bytes,6,opt,name=marketID,proto3" json:"marketID,omitempty"`
	// The amount of the asset supplied
	SupplyAmount string `protobuf:"bytes,7,opt,name=supplyAmount,proto3" json:"supplyAmount,omitempty"`
	// The amount of the asset demanded
	DemandAmount string `protobuf:"bytes,8,opt,name=demandAmount,proto3" json:"demandAmount,omitempty"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt      uint64                  `protobuf:"varint,9,opt,name=salt,proto3" json:"salt,omitempty"`
	OrderType BaseSpotOrder_OrderType `protobuf:"varint,10,opt,name=orderType,proto3,enum=injective.exchange.v1beta1.BaseSpotOrder_OrderType" json:"orderType,omitempty"`
	// use this for stop/take orders in the future
	TriggerPrice string `protobuf:"bytes,11,opt,name=triggerPrice,proto3" json:"triggerPrice,omitempty"`
	// Order signature.
	Signature string `protobuf:"bytes,12,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BaseSpotOrder) Reset()         { *m = BaseSpotOrder{} }
func (m *BaseSpotOrder) String() string { return proto.CompactTextString(m) }
func (*BaseSpotOrder) ProtoMessage()    {}
func (*BaseSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{4}
}
func (m *BaseSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseSpotOrder.Merge(m, src)
}
func (m *BaseSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *BaseSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_BaseSpotOrder proto.InternalMessageInfo

func (m *BaseSpotOrder) GetChainId() int64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *BaseSpotOrder) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

func (m *BaseSpotOrder) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *BaseSpotOrder) GetFeeRecipient() string {
	if m != nil {
		return m.FeeRecipient
	}
	return ""
}

func (m *BaseSpotOrder) GetExpiry() uint64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *BaseSpotOrder) GetMarketID() string {
	if m != nil {
		return m.MarketID
	}
	return ""
}

func (m *BaseSpotOrder) GetSupplyAmount() string {
	if m != nil {
		return m.SupplyAmount
	}
	return ""
}

func (m *BaseSpotOrder) GetDemandAmount() string {
	if m != nil {
		return m.DemandAmount
	}
	return ""
}

func (m *BaseSpotOrder) GetSalt() uint64 {
	if m != nil {
		return m.Salt
	}
	return 0
}

func (m *BaseSpotOrder) GetOrderType() BaseSpotOrder_OrderType {
	if m != nil {
		return m.OrderType
	}
	return BaseSpotOrder_LIMIT_BUY
}

func (m *BaseSpotOrder) GetTriggerPrice() string {
	if m != nil {
		return m.TriggerPrice
	}
	return ""
}

func (m *BaseSpotOrder) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// A valid signed 0x order based on the schema.
type BaseOrder struct {
	// Specify chain ID.
	ChainId int64 `protobuf:"zigzag64,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Exchange v3 contract address.
	ExchangeAddress string `protobuf:"bytes,2,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	// Address that created the order.
	MakerAddress string `protobuf:"bytes,3,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress string `protobuf:"bytes,4,opt,name=taker_address,json=takerAddress,proto3" json:"taker_address,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `protobuf:"bytes,5,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `protobuf:"bytes,6,opt,name=sender_address,json=senderAddress,proto3" json:"sender_address,omitempty"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount string `protobuf:"bytes,7,opt,name=maker_asset_amount,json=makerAssetAmount,proto3" json:"maker_asset_amount,omitempty"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount string `protobuf:"bytes,8,opt,name=taker_asset_amount,json=takerAssetAmount,proto3" json:"taker_asset_amount,omitempty"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `protobuf:"bytes,9,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `protobuf:"bytes,10,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds string `protobuf:"bytes,11,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt string `protobuf:"bytes,12,opt,name=salt,proto3" json:"salt,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,13,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,14,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `protobuf:"bytes,15,opt,name=maker_fee_asset_data,json=makerFeeAssetData,proto3" json:"maker_fee_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `protobuf:"bytes,16,opt,name=taker_fee_asset_data,json=takerFeeAssetData,proto3" json:"taker_fee_asset_data,omitempty"`
	// Order signature.
	Signature string `protobuf:"bytes,17,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BaseOrder) Reset()         { *m = BaseOrder{} }
func (m *BaseOrder) String() string { return proto.CompactTextString(m) }
func (*BaseOrder) ProtoMessage()    {}
func (*BaseOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{5}
}
func (m *BaseOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseOrder.Merge(m, src)
}
func (m *BaseOrder) XXX_Size() int {
	return m.Size()
}
func (m *BaseOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseOrder.DiscardUnknown(m)
}

var xxx_messageInfo_BaseOrder proto.InternalMessageInfo

func (m *BaseOrder) GetChainId() int64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *BaseOrder) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *BaseOrder) GetTakerAddress() string {
	if m != nil {
		return m.TakerAddress
	}
	return ""
}

func (m *BaseOrder) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *BaseOrder) GetSenderAddress() string {
	if m != nil {
		return m.SenderAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetAmount() string {
	if m != nil {
		return m.MakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetAmount() string {
	if m != nil {
		return m.TakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetMakerFee() string {
	if m != nil {
		return m.MakerFee
	}
	return ""
}

func (m *BaseOrder) GetTakerFee() string {
	if m != nil {
		return m.TakerFee
	}
	return ""
}

func (m *BaseOrder) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *BaseOrder) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetMakerFeeAssetData() string {
	if m != nil {
		return m.MakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerFeeAssetData() string {
	if m != nil {
		return m.TakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// A valid signed 0x order with Metadata.
type Order struct {
	Order                 *BaseOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	TradePairHash         string     `protobuf:"bytes,2,opt,name=trade_pair_hash,json=tradePairHash,proto3" json:"trade_pair_hash,omitempty"`
	FilledAmount          string     `protobuf:"bytes,3,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount,omitempty"`
	Status                int64      `protobuf:"zigzag64,4,opt,name=status,proto3" json:"status,omitempty"`
	IndexPriceRequirement string     `protobuf:"bytes,5,opt,name=index_price_requirement,json=indexPriceRequirement,proto3" json:"index_price_requirement,omitempty"`
	SubaccountID          string     `protobuf:"bytes,6,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
	OrderType             uint64     `protobuf:"varint,7,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
	TriggerPrice          string     `protobuf:"bytes,8,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{6}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrder() *BaseOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Order) GetTradePairHash() string {
	if m != nil {
		return m.TradePairHash
	}
	return ""
}

func (m *Order) GetFilledAmount() string {
	if m != nil {
		return m.FilledAmount
	}
	return ""
}

func (m *Order) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Order) GetIndexPriceRequirement() string {
	if m != nil {
		return m.IndexPriceRequirement
	}
	return ""
}

func (m *Order) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

func (m *Order) GetOrderType() uint64 {
	if m != nil {
		return m.OrderType
	}
	return 0
}

func (m *Order) GetTriggerPrice() string {
	if m != nil {
		return m.TriggerPrice
	}
	return ""
}

// An subaccount's margin info for a given base currency
type MarginInfo struct {
	MarginHold    string `protobuf:"bytes,1,opt,name=margin_hold,json=marginHold,proto3" json:"margin_hold,omitempty"`
	TotalDeposits string `protobuf:"bytes,2,opt,name=total_deposits,json=totalDeposits,proto3" json:"total_deposits,omitempty"`
}

func (m *MarginInfo) Reset()         { *m = MarginInfo{} }
func (m *MarginInfo) String() string { return proto.CompactTextString(m) }
func (*MarginInfo) ProtoMessage()    {}
func (*MarginInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{7}
}
func (m *MarginInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarginInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarginInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarginInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarginInfo.Merge(m, src)
}
func (m *MarginInfo) XXX_Size() int {
	return m.Size()
}
func (m *MarginInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MarginInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MarginInfo proto.InternalMessageInfo

func (m *MarginInfo) GetMarginHold() string {
	if m != nil {
		return m.MarginHold
	}
	return ""
}

func (m *MarginInfo) GetTotalDeposits() string {
	if m != nil {
		return m.TotalDeposits
	}
	return ""
}

// An subaccount's margin info for a given base currency
type BaseCurrencyMarginInfo struct {
	MarginHold    string `protobuf:"bytes,1,opt,name=margin_hold,json=marginHold,proto3" json:"margin_hold,omitempty"`
	TotalDeposits string `protobuf:"bytes,2,opt,name=total_deposits,json=totalDeposits,proto3" json:"total_deposits,omitempty"`
	BaseCurrency  string `protobuf:"bytes,3,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
}

func (m *BaseCurrencyMarginInfo) Reset()         { *m = BaseCurrencyMarginInfo{} }
func (m *BaseCurrencyMarginInfo) String() string { return proto.CompactTextString(m) }
func (*BaseCurrencyMarginInfo) ProtoMessage()    {}
func (*BaseCurrencyMarginInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{8}
}
func (m *BaseCurrencyMarginInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseCurrencyMarginInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseCurrencyMarginInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseCurrencyMarginInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseCurrencyMarginInfo.Merge(m, src)
}
func (m *BaseCurrencyMarginInfo) XXX_Size() int {
	return m.Size()
}
func (m *BaseCurrencyMarginInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseCurrencyMarginInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BaseCurrencyMarginInfo proto.InternalMessageInfo

func (m *BaseCurrencyMarginInfo) GetMarginHold() string {
	if m != nil {
		return m.MarginHold
	}
	return ""
}

func (m *BaseCurrencyMarginInfo) GetTotalDeposits() string {
	if m != nil {
		return m.TotalDeposits
	}
	return ""
}

func (m *BaseCurrencyMarginInfo) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

// An subaccount's margin info for a given base currency
type SubaccountInfo struct {
	BaseCurrencyMarginInfo []*BaseCurrencyMarginInfo `protobuf:"bytes,1,rep,name=base_currency_margin_info,json=baseCurrencyMarginInfo,proto3" json:"base_currency_margin_info,omitempty"`
	Nonce                  string                    `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	SubaccountId           string                    `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
}

func (m *SubaccountInfo) Reset()         { *m = SubaccountInfo{} }
func (m *SubaccountInfo) String() string { return proto.CompactTextString(m) }
func (*SubaccountInfo) ProtoMessage()    {}
func (*SubaccountInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{9}
}
func (m *SubaccountInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountInfo.Merge(m, src)
}
func (m *SubaccountInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountInfo proto.InternalMessageInfo

func (m *SubaccountInfo) GetBaseCurrencyMarginInfo() []*BaseCurrencyMarginInfo {
	if m != nil {
		return m.BaseCurrencyMarginInfo
	}
	return nil
}

func (m *SubaccountInfo) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *SubaccountInfo) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

// An orderquote info for a given market
type OrderQuoteInfo struct {
	MarketId string        `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Quotes   []*OrderQuote `protobuf:"bytes,2,rep,name=quotes,proto3" json:"quotes,omitempty"`
}

func (m *OrderQuoteInfo) Reset()         { *m = OrderQuoteInfo{} }
func (m *OrderQuoteInfo) String() string { return proto.CompactTextString(m) }
func (*OrderQuoteInfo) ProtoMessage()    {}
func (*OrderQuoteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{10}
}
func (m *OrderQuoteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderQuoteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderQuoteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderQuoteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderQuoteInfo.Merge(m, src)
}
func (m *OrderQuoteInfo) XXX_Size() int {
	return m.Size()
}
func (m *OrderQuoteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderQuoteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OrderQuoteInfo proto.InternalMessageInfo

func (m *OrderQuoteInfo) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *OrderQuoteInfo) GetQuotes() []*OrderQuote {
	if m != nil {
		return m.Quotes
	}
	return nil
}

type PositionInfo struct {
	IsLong                 bool   `protobuf:"varint,1,opt,name=isLong,proto3" json:"isLong,omitempty"`
	BankruptcyPrice        string `protobuf:"bytes,2,opt,name=bankruptcy_price,json=bankruptcyPrice,proto3" json:"bankruptcy_price,omitempty"`
	Quantity               string `protobuf:"bytes,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	PositionHoldQuantity   string `protobuf:"bytes,4,opt,name=positionHoldQuantity,proto3" json:"positionHoldQuantity,omitempty"`
	CumulativeFundingEntry string `protobuf:"bytes,5,opt,name=cumulativeFundingEntry,proto3" json:"cumulativeFundingEntry,omitempty"`
	Margin                 string `protobuf:"bytes,6,opt,name=margin,proto3" json:"margin,omitempty"`
	EntryPrice             string `protobuf:"bytes,7,opt,name=entryPrice,proto3" json:"entryPrice,omitempty"`
}

func (m *PositionInfo) Reset()         { *m = PositionInfo{} }
func (m *PositionInfo) String() string { return proto.CompactTextString(m) }
func (*PositionInfo) ProtoMessage()    {}
func (*PositionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{11}
}
func (m *PositionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionInfo.Merge(m, src)
}
func (m *PositionInfo) XXX_Size() int {
	return m.Size()
}
func (m *PositionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PositionInfo proto.InternalMessageInfo

func (m *PositionInfo) GetIsLong() bool {
	if m != nil {
		return m.IsLong
	}
	return false
}

func (m *PositionInfo) GetBankruptcyPrice() string {
	if m != nil {
		return m.BankruptcyPrice
	}
	return ""
}

func (m *PositionInfo) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *PositionInfo) GetPositionHoldQuantity() string {
	if m != nil {
		return m.PositionHoldQuantity
	}
	return ""
}

func (m *PositionInfo) GetCumulativeFundingEntry() string {
	if m != nil {
		return m.CumulativeFundingEntry
	}
	return ""
}

func (m *PositionInfo) GetMargin() string {
	if m != nil {
		return m.Margin
	}
	return ""
}

func (m *PositionInfo) GetEntryPrice() string {
	if m != nil {
		return m.EntryPrice
	}
	return ""
}

// An order quote with fillable data
type OrderQuote struct {
	Order          *BaseOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	FillableAmount string     `protobuf:"bytes,2,opt,name=fillable_amount,json=fillableAmount,proto3" json:"fillable_amount,omitempty"`
}

func (m *OrderQuote) Reset()         { *m = OrderQuote{} }
func (m *OrderQuote) String() string { return proto.CompactTextString(m) }
func (*OrderQuote) ProtoMessage()    {}
func (*OrderQuote) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{12}
}
func (m *OrderQuote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderQuote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderQuote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderQuote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderQuote.Merge(m, src)
}
func (m *OrderQuote) XXX_Size() int {
	return m.Size()
}
func (m *OrderQuote) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderQuote.DiscardUnknown(m)
}

var xxx_messageInfo_OrderQuote proto.InternalMessageInfo

func (m *OrderQuote) GetOrder() *BaseOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *OrderQuote) GetFillableAmount() string {
	if m != nil {
		return m.FillableAmount
	}
	return ""
}

// An orderbook price level
type PriceLevel struct {
	// price
	P string `protobuf:"bytes,1,opt,name=p,proto3" json:"p,omitempty"`
	// quantity
	Q string `protobuf:"bytes,2,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *PriceLevel) Reset()         { *m = PriceLevel{} }
func (m *PriceLevel) String() string { return proto.CompactTextString(m) }
func (*PriceLevel) ProtoMessage()    {}
func (*PriceLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{13}
}
func (m *PriceLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceLevel.Merge(m, src)
}
func (m *PriceLevel) XXX_Size() int {
	return m.Size()
}
func (m *PriceLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceLevel.DiscardUnknown(m)
}

var xxx_messageInfo_PriceLevel proto.InternalMessageInfo

func (m *PriceLevel) GetP() string {
	if m != nil {
		return m.P
	}
	return ""
}

func (m *PriceLevel) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

// A 0x Transaction Exchange Domain
type ExchangeDomain struct {
	// Address of the Injective Coordinator Contract.
	VerifyingContract string `protobuf:"bytes,1,opt,name=verifying_contract,json=verifyingContract,proto3" json:"verifying_contract,omitempty"`
	// Ethereum Chain ID of the transaction
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *ExchangeDomain) Reset()         { *m = ExchangeDomain{} }
func (m *ExchangeDomain) String() string { return proto.CompactTextString(m) }
func (*ExchangeDomain) ProtoMessage()    {}
func (*ExchangeDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{14}
}
func (m *ExchangeDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDomain.Merge(m, src)
}
func (m *ExchangeDomain) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDomain.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDomain proto.InternalMessageInfo

func (m *ExchangeDomain) GetVerifyingContract() string {
	if m != nil {
		return m.VerifyingContract
	}
	return ""
}

func (m *ExchangeDomain) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// A valid signed 0x Signed Transaction
type SignedTransaction struct {
	// Arbitrary number to facilitate uniqueness of the transactions's hash.
	Salt string `protobuf:"bytes,1,opt,name=salt,proto3" json:"salt,omitempty"`
	// Address of transaction signer
	SignerAddress string `protobuf:"bytes,2,opt,name=signer_address,json=signerAddress,proto3" json:"signer_address,omitempty"`
	// The calldata that is to be executed. This must call an Exchange contract
	// method.
	Data string `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// Timestamp in seconds at which transaction expires.
	ExpirationTimeSeconds string `protobuf:"bytes,4,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// gasPrice that transaction is required to be executed with.
	GasPrice string `protobuf:"bytes,5,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	// Exchange Domain specific values.
	Domain *ExchangeDomain `protobuf:"bytes,6,opt,name=domain,proto3" json:"domain,omitempty"`
	// Signature of the 0x Transaction
	Signature string `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SignedTransaction) Reset()         { *m = SignedTransaction{} }
func (m *SignedTransaction) String() string { return proto.CompactTextString(m) }
func (*SignedTransaction) ProtoMessage()    {}
func (*SignedTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2116e2804e9c53f9, []int{15}
}
func (m *SignedTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransaction.Merge(m, src)
}
func (m *SignedTransaction) XXX_Size() int {
	return m.Size()
}
func (m *SignedTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransaction proto.InternalMessageInfo

func (m *SignedTransaction) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *SignedTransaction) GetSignerAddress() string {
	if m != nil {
		return m.SignerAddress
	}
	return ""
}

func (m *SignedTransaction) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *SignedTransaction) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *SignedTransaction) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *SignedTransaction) GetDomain() *ExchangeDomain {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *SignedTransaction) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func init() {
	proto.RegisterEnum("injective.exchange.v1beta1.SpotLimitOrder_LimitOrderType", SpotLimitOrder_LimitOrderType_name, SpotLimitOrder_LimitOrderType_value)
	proto.RegisterEnum("injective.exchange.v1beta1.SpotMarketOrder_MarketOrderType", SpotMarketOrder_MarketOrderType_name, SpotMarketOrder_MarketOrderType_value)
	proto.RegisterEnum("injective.exchange.v1beta1.BaseSpotOrder_OrderType", BaseSpotOrder_OrderType_name, BaseSpotOrder_OrderType_value)
	proto.RegisterType((*DerivativeMarket)(nil), "injective.exchange.v1beta1.DerivativeMarket")
	proto.RegisterType((*SpotMarket)(nil), "injective.exchange.v1beta1.SpotMarket")
	proto.RegisterType((*SpotLimitOrder)(nil), "injective.exchange.v1beta1.SpotLimitOrder")
	proto.RegisterType((*SpotMarketOrder)(nil), "injective.exchange.v1beta1.SpotMarketOrder")
	proto.RegisterType((*BaseSpotOrder)(nil), "injective.exchange.v1beta1.BaseSpotOrder")
	proto.RegisterType((*BaseOrder)(nil), "injective.exchange.v1beta1.BaseOrder")
	proto.RegisterType((*Order)(nil), "injective.exchange.v1beta1.Order")
	proto.RegisterType((*MarginInfo)(nil), "injective.exchange.v1beta1.MarginInfo")
	proto.RegisterType((*BaseCurrencyMarginInfo)(nil), "injective.exchange.v1beta1.BaseCurrencyMarginInfo")
	proto.RegisterType((*SubaccountInfo)(nil), "injective.exchange.v1beta1.SubaccountInfo")
	proto.RegisterType((*OrderQuoteInfo)(nil), "injective.exchange.v1beta1.OrderQuoteInfo")
	proto.RegisterType((*PositionInfo)(nil), "injective.exchange.v1beta1.PositionInfo")
	proto.RegisterType((*OrderQuote)(nil), "injective.exchange.v1beta1.OrderQuote")
	proto.RegisterType((*PriceLevel)(nil), "injective.exchange.v1beta1.PriceLevel")
	proto.RegisterType((*ExchangeDomain)(nil), "injective.exchange.v1beta1.ExchangeDomain")
	proto.RegisterType((*SignedTransaction)(nil), "injective.exchange.v1beta1.SignedTransaction")
}

func init() {
	proto.RegisterFile("injective/exchange/v1beta1/exchange.proto", fileDescriptor_2116e2804e9c53f9)
}

var fileDescriptor_2116e2804e9c53f9 = []byte{
	// 1798 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x6e, 0x1b, 0xc7,
	0x15, 0xd6, 0x52, 0xfc, 0x3d, 0x14, 0x29, 0x6a, 0x2c, 0xab, 0x1b, 0xa7, 0x51, 0xdd, 0x75, 0x92,
	0x2a, 0x45, 0x22, 0xd5, 0x4a, 0x11, 0xb4, 0x08, 0x50, 0x40, 0x8a, 0x64, 0x58, 0x88, 0xdc, 0xd8,
	0x2b, 0x15, 0x45, 0x72, 0xb3, 0x18, 0xee, 0x8e, 0xc8, 0xa9, 0xc8, 0x59, 0x6a, 0x76, 0x28, 0x48,
	0x0f, 0xd0, 0x9b, 0x5e, 0xb5, 0x97, 0x7d, 0x80, 0xde, 0xf5, 0x09, 0xfa, 0x04, 0x05, 0x8a, 0x02,
	0xbe, 0x2a, 0x7a, 0x59, 0xd8, 0x8f, 0xd0, 0x17, 0x28, 0xce, 0xcc, 0xec, 0x1f, 0x45, 0x93, 0x02,
	0x9a, 0x3b, 0xce, 0x77, 0xbe, 0x33, 0xb3, 0x73, 0xfe, 0x87, 0xf0, 0x09, 0x17, 0xbf, 0x63, 0xa1,
	0xe2, 0xd7, 0x6c, 0x8f, 0xdd, 0x84, 0x43, 0x2a, 0x06, 0x6c, 0xef, 0xfa, 0x69, 0x9f, 0x29, 0xfa,
	0x34, 0x03, 0x76, 0x27, 0x32, 0x56, 0x31, 0x79, 0x94, 0x51, 0x77, 0x33, 0x89, 0xa5, 0x3e, 0xda,
	0x1c, 0xc4, 0x83, 0x58, 0xd3, 0xf6, 0xf0, 0x97, 0xd1, 0xf0, 0xde, 0x56, 0xa1, 0x77, 0xc4, 0x24,
	0xbf, 0xa6, 0xa8, 0xf5, 0x82, 0xca, 0x4b, 0xa6, 0xc8, 0x16, 0xd4, 0x15, 0x0f, 0x2f, 0x99, 0x74,
	0x9d, 0xc7, 0xce, 0x4e, 0xcb, 0xb7, 0x2b, 0xc4, 0x63, 0x49, 0xc3, 0x11, 0x73, 0x2b, 0x06, 0x37,
	0x2b, 0xf2, 0x04, 0x3a, 0x7d, 0x9a, 0xb0, 0x20, 0x9c, 0x4a, 0xc9, 0x44, 0x78, 0xeb, 0xae, 0x6a,
	0xf1, 0x1a, 0x82, 0x5f, 0x59, 0x8c, 0x6c, 0x42, 0x4d, 0xc4, 0x22, 0x64, 0x6e, 0x55, 0x0b, 0xcd,
	0x82, 0xbc, 0x0f, 0xad, 0xb1, 0x3e, 0x34, 0xe0, 0x91, 0x5b, 0xd3, 0x92, 0xa6, 0x01, 0x4e, 0x22,
	0xe2, 0x42, 0x83, 0x09, 0xda, 0x1f, 0xb1, 0xc8, 0xad, 0x3f, 0x76, 0x76, 0x9a, 0x7e, 0xba, 0x24,
	0x9f, 0x40, 0x2f, 0xbd, 0x60, 0x40, 0xa3, 0x48, 0xb2, 0x24, 0x71, 0x1b, 0x5a, 0x7b, 0x3d, 0xc5,
	0x0f, 0x0c, 0x4c, 0x7e, 0x0c, 0x6b, 0x13, 0xc9, 0x43, 0x16, 0x5c, 0xd0, 0x50, 0xc5, 0xd2, 0x6d,
	0x6a, 0x5a, 0x5b, 0x63, 0xcf, 0x34, 0x44, 0x7e, 0x04, 0x6d, 0x2e, 0x22, 0x76, 0x13, 0x68, 0xd0,
	0x6d, 0x69, 0x06, 0x68, 0xe8, 0x25, 0x22, 0xe4, 0x67, 0xb0, 0xc9, 0x05, 0x57, 0x9c, 0x8e, 0x82,
	0x31, 0x95, 0x03, 0x2e, 0x02, 0x49, 0x15, 0x8f, 0x5d, 0xd0, 0x4c, 0x62, 0x65, 0x2f, 0xb4, 0xc8,
	0x47, 0x09, 0xf9, 0x05, 0xb8, 0x63, 0xca, 0x85, 0x62, 0x82, 0x8a, 0x90, 0x95, 0xb5, 0xda, 0x5a,
	0x6b, 0xab, 0x20, 0x2f, 0x6a, 0x3e, 0x86, 0xb5, 0x31, 0xbd, 0x64, 0x32, 0x50, 0x37, 0xc1, 0x05,
	0x63, 0xee, 0x9a, 0xf9, 0x1a, 0x8d, 0x9d, 0xdf, 0x3c, 0x63, 0x0c, 0x19, 0xaa, 0xc8, 0xe8, 0x18,
	0x86, 0xca, 0x19, 0x3f, 0x87, 0x2d, 0xc1, 0x6e, 0x54, 0x70, 0x31, 0x15, 0x11, 0x17, 0x83, 0x40,
	0xf1, 0x31, 0x4b, 0x14, 0x1d, 0x4f, 0xdc, 0xae, 0xe6, 0x6e, 0xa2, 0xf4, 0x99, 0x11, 0x9e, 0xa7,
	0x32, 0x34, 0x6a, 0xaa, 0x80, 0x5f, 0x26, 0xaf, 0xe9, 0xc8, 0x5d, 0x37, 0x46, 0xb5, 0xf8, 0x89,
	0x85, 0xc9, 0x67, 0x40, 0xc2, 0xe9, 0x78, 0x3a, 0xd2, 0x51, 0x93, 0x1e, 0xe3, 0xf6, 0x34, 0x79,
	0x23, 0x97, 0xd8, 0x23, 0xbc, 0x3f, 0x54, 0x00, 0xce, 0x26, 0xb1, 0x5a, 0x12, 0x5f, 0x1f, 0x00,
	0xe8, 0x38, 0xa2, 0x49, 0xc2, 0x94, 0x8d, 0xb1, 0x16, 0x22, 0x07, 0x08, 0xa0, 0x9b, 0xae, 0xa6,
	0xb1, 0x4a, 0xe5, 0x26, 0xc8, 0x40, 0x43, 0x86, 0x30, 0x6b, 0xba, 0xea, 0x52, 0xd3, 0xd5, 0xee,
	0x98, 0xae, 0x14, 0x90, 0xf5, 0x77, 0x07, 0x64, 0x63, 0x79, 0x40, 0x36, 0xe7, 0x06, 0xa4, 0xf7,
	0xaf, 0x55, 0xe8, 0xa2, 0x31, 0x4e, 0xf9, 0x98, 0xab, 0x6f, 0x64, 0xc4, 0x24, 0xf1, 0x60, 0x2d,
	0x99, 0xf6, 0x69, 0x18, 0xc6, 0x53, 0xa1, 0x4e, 0x8e, 0xac, 0x59, 0x4a, 0x18, 0x1a, 0x2d, 0x61,
	0x22, 0x62, 0x32, 0x4d, 0x3e, 0xb3, 0x42, 0xdd, 0x0b, 0xc6, 0x7c, 0x16, 0xf2, 0x09, 0x67, 0x22,
	0x35, 0x4b, 0x09, 0x43, 0x5d, 0x76, 0x33, 0xe1, 0xf2, 0x56, 0x9b, 0xa4, 0xea, 0xdb, 0x95, 0x39,
	0x77, 0x32, 0x19, 0xdd, 0x1e, 0x8c, 0xf1, 0x14, 0x6b, 0x8e, 0x12, 0x86, 0x9c, 0x88, 0x8d, 0xa9,
	0x88, 0x2c, 0xc7, 0xd8, 0xa4, 0x84, 0xe9, 0x6f, 0xe0, 0xa3, 0x11, 0x4b, 0x39, 0x0d, 0xfb, 0x0d,
	0x05, 0x8c, 0xec, 0xc3, 0xc3, 0x50, 0x32, 0x0c, 0x71, 0x11, 0xf4, 0x47, 0x71, 0x78, 0x19, 0x0c,
	0x19, 0x1f, 0x0c, 0x95, 0x36, 0xd3, 0xaa, 0xff, 0x20, 0x15, 0x1e, 0xa2, 0xec, 0xb9, 0x16, 0x91,
	0xdf, 0x42, 0x2b, 0x46, 0x03, 0x9d, 0xdf, 0x4e, 0x4c, 0x5a, 0x76, 0xf7, 0x7f, 0xb9, 0xfb, 0xee,
	0x1a, 0xb7, 0x5b, 0x36, 0xeb, 0x6e, 0xfe, 0x13, 0x37, 0xf0, 0xf3, 0xbd, 0xf0, 0x83, 0x95, 0xe4,
	0x83, 0x01, 0x93, 0x3a, 0xc1, 0x6d, 0x22, 0x97, 0x30, 0x6f, 0x0f, 0xba, 0xe5, 0x0d, 0x48, 0x0b,
	0x6a, 0xa7, 0x27, 0x2f, 0x4e, 0xce, 0x7b, 0x2b, 0xa4, 0x09, 0xd5, 0xb3, 0xf3, 0x6f, 0x5e, 0xf6,
	0x1c, 0xfc, 0x75, 0x7e, 0xf0, 0xf5, 0x71, 0xaf, 0xe2, 0xfd, 0xb3, 0x02, 0xeb, 0x79, 0x94, 0xdf,
	0xdf, 0xb3, 0xb3, 0x1e, 0xac, 0xcc, 0xf1, 0xe0, 0x23, 0x68, 0x5e, 0x4d, 0xa9, 0x50, 0x5c, 0xa5,
	0xd5, 0x35, 0x5b, 0x93, 0x0f, 0xa1, 0x83, 0x19, 0x98, 0x9c, 0xa1, 0xdb, 0x38, 0x8b, 0x6c, 0xdc,
	0x97, 0x41, 0xf2, 0x6d, 0xd1, 0x96, 0x35, 0x6d, 0xcb, 0x2f, 0x97, 0xd9, 0xb2, 0x70, 0x93, 0xdd,
	0xc2, 0xef, 0x65, 0xd6, 0xac, 0xcf, 0xb1, 0xe6, 0x53, 0x58, 0x9f, 0xd9, 0x81, 0x00, 0xd4, 0x5f,
	0x1c, 0xf8, 0x5f, 0x1f, 0xbf, 0xcb, 0x9e, 0x7f, 0xa9, 0x41, 0xe7, 0x90, 0x26, 0x0c, 0xbf, 0xc4,
	0x58, 0xf3, 0x3d, 0x68, 0x86, 0x43, 0xca, 0x05, 0xe6, 0x26, 0x5a, 0x92, 0xf8, 0x0d, 0xbd, 0x3e,
	0x89, 0xee, 0x18, 0xba, 0xb2, 0x30, 0x85, 0x56, 0x17, 0xa6, 0x50, 0x75, 0x61, 0x0a, 0xd5, 0x4a,
	0x29, 0xf4, 0x08, 0xd2, 0xf2, 0x70, 0x34, 0x53, 0x2e, 0x8e, 0xee, 0xa4, 0x57, 0xe3, 0x1e, 0xe9,
	0xd5, 0x9c, 0x93, 0x5e, 0x04, 0xaa, 0x09, 0x1d, 0x29, 0x9d, 0x01, 0x55, 0x5f, 0xff, 0x26, 0xaf,
	0x8a, 0xee, 0x04, 0xed, 0xce, 0xcf, 0x17, 0xb9, 0xb3, 0x64, 0xc8, 0xdd, 0x7b, 0xb9, 0xb1, 0x7d,
	0xd7, 0x8d, 0xe4, 0x87, 0xd0, 0x4a, 0xf8, 0x40, 0x50, 0x35, 0x95, 0x69, 0x6b, 0xca, 0x01, 0xef,
	0xbf, 0x0e, 0xb4, 0x72, 0xff, 0x76, 0xa0, 0xa5, 0xd3, 0x25, 0x38, 0xfc, 0xcd, 0xb7, 0xbd, 0x15,
	0xd2, 0x05, 0x30, 0xcb, 0xb3, 0xe3, 0xd3, 0xd3, 0x9e, 0x83, 0x6b, 0xe3, 0x7e, 0x2d, 0xaf, 0x90,
	0x75, 0x68, 0xdb, 0xb5, 0x26, 0xac, 0x12, 0x02, 0x5d, 0x8c, 0x89, 0x20, 0xdf, 0xa4, 0x4a, 0x1e,
	0xc0, 0x7a, 0x01, 0xd3, 0xc4, 0x5a, 0x06, 0x16, 0xb6, 0xab, 0x93, 0x4d, 0xe8, 0x15, 0x41, 0x4d,
	0x6d, 0xe0, 0x9e, 0x18, 0x5d, 0x85, 0x3d, 0x9b, 0xa8, 0x5e, 0xc0, 0x34, 0xb1, 0x95, 0x81, 0x85,
	0x3d, 0x01, 0xf7, 0x2c, 0x82, 0x9a, 0xda, 0xf6, 0xfe, 0x5a, 0x83, 0x16, 0x9a, 0x77, 0x69, 0x8c,
	0xce, 0x6b, 0x12, 0x95, 0xf9, 0x53, 0xcb, 0x13, 0xe8, 0x98, 0x56, 0x96, 0xf2, 0x6c, 0x59, 0xd7,
	0x60, 0x81, 0xa4, 0x4a, 0x24, 0x1b, 0xb8, 0xaa, 0x48, 0xda, 0x87, 0x87, 0x17, 0x8c, 0x05, 0x32,
	0x8d, 0xe4, 0x8c, 0x6c, 0x8a, 0xfd, 0x83, 0x62, 0x94, 0xa7, 0x3a, 0x1f, 0x41, 0xd7, 0xa4, 0x46,
	0x46, 0x36, 0xa1, 0xdd, 0x31, 0x68, 0x4a, 0xfb, 0x14, 0x88, 0xfd, 0x48, 0x6c, 0xbf, 0x01, 0x2d,
	0x46, 0x79, 0xcf, 0x7c, 0x29, 0x0a, 0x6c, 0x14, 0x7f, 0x0a, 0x44, 0xdd, 0x65, 0x9b, 0x78, 0xef,
	0xa9, 0x59, 0xb6, 0xee, 0xc3, 0xc8, 0xc6, 0x36, 0xdd, 0x4a, 0x13, 0xeb, 0x92, 0x49, 0xdb, 0xa4,
	0x55, 0x26, 0x34, 0xb5, 0xbb, 0xa9, 0x52, 0xe1, 0x17, 0xf0, 0x03, 0x9d, 0x9b, 0xa6, 0xd5, 0xe0,
	0xe8, 0x13, 0x24, 0x2c, 0x8c, 0x45, 0x94, 0xd8, 0x88, 0x7e, 0x98, 0x8b, 0x71, 0xf8, 0x39, 0x33,
	0xc2, 0x2c, 0xcb, 0x4c, 0x54, 0x9b, 0x2c, 0xdb, 0x81, 0x5e, 0xf1, 0x86, 0x11, 0x55, 0xd4, 0x8e,
	0x5b, 0xdd, 0xfc, 0x7e, 0x47, 0x54, 0x51, 0x64, 0xaa, 0x59, 0xa6, 0x19, 0xb6, 0xba, 0xaa, 0xcc,
	0xdc, 0x83, 0xcd, 0xec, 0x66, 0x45, 0xb6, 0x19, 0xb5, 0x36, 0xd2, 0x4b, 0x96, 0x14, 0xd4, 0x3c,
	0x05, 0x3b, 0x6e, 0xa9, 0x3b, 0x0a, 0xa5, 0x24, 0xdd, 0x98, 0x4d, 0xd2, 0x7f, 0x54, 0xa0, 0x66,
	0x42, 0xf5, 0x4b, 0xa8, 0xe9, 0xec, 0xd7, 0x71, 0xda, 0xde, 0xff, 0x68, 0x59, 0xfd, 0xd0, 0x5a,
	0xbe, 0xd1, 0x21, 0x1f, 0xc3, 0xba, 0x92, 0x34, 0x62, 0xc1, 0x84, 0x72, 0x19, 0x0c, 0x69, 0x32,
	0xb4, 0xb1, 0xdc, 0xd1, 0xf0, 0x4b, 0xca, 0xe5, 0x73, 0x9a, 0x0c, 0x31, 0x48, 0xcd, 0x1c, 0x90,
	0x7a, 0x7c, 0x75, 0xce, 0x70, 0x80, 0x95, 0x59, 0x51, 0x35, 0x35, 0x21, 0x4c, 0x7c, 0xbb, 0x42,
	0x5f, 0x16, 0x26, 0xf3, 0x40, 0xb2, 0xab, 0x29, 0x97, 0x6c, 0xcc, 0xb2, 0x59, 0xe5, 0x61, 0x3e,
	0xa5, 0xfb, 0xb9, 0x90, 0x7c, 0x08, 0xdd, 0xbc, 0xf2, 0x07, 0x3c, 0x48, 0x47, 0xb9, 0x72, 0x3f,
	0xf8, 0x00, 0x40, 0xdf, 0x25, 0x50, 0x58, 0x44, 0x1b, 0xba, 0xba, 0x16, 0xea, 0x21, 0xa6, 0x97,
	0xa9, 0x7d, 0xf6, 0x61, 0xd0, 0x9c, 0xd3, 0xd7, 0xce, 0x01, 0xcc, 0xf4, 0x7e, 0x22, 0x2e, 0x62,
	0x1c, 0x51, 0xed, 0xa8, 0x3f, 0x8c, 0x47, 0x91, 0xed, 0xf6, 0x60, 0xa0, 0xe7, 0xf1, 0x28, 0xc2,
	0xcc, 0x52, 0xb1, 0xa2, 0xa3, 0x20, 0x62, 0x93, 0x38, 0xe1, 0x2a, 0xc9, 0x8c, 0x86, 0xe8, 0x91,
	0x05, 0xbd, 0xdf, 0x3b, 0xb0, 0x75, 0x58, 0x78, 0x3d, 0x7d, 0xff, 0x47, 0xdc, 0xeb, 0xd1, 0xe6,
	0xfd, 0xcd, 0x81, 0xee, 0x59, 0x6e, 0x32, 0x3c, 0x7f, 0x0c, 0xef, 0x95, 0xf4, 0xd2, 0xb7, 0x0d,
	0x17, 0x17, 0xb1, 0xeb, 0x3c, 0x5e, 0xdd, 0x69, 0xef, 0xef, 0x2f, 0x0b, 0xa4, 0xbb, 0xd7, 0xf2,
	0xb7, 0xfa, 0xf3, 0xaf, 0x9b, 0x3d, 0x1b, 0x2b, 0xc5, 0x67, 0xe3, 0x13, 0xe8, 0x14, 0xfd, 0x1b,
	0xa5, 0x1f, 0x5f, 0x70, 0x6f, 0xe4, 0x8d, 0xa1, 0xab, 0x23, 0xf6, 0x15, 0xbe, 0x10, 0xf4, 0x66,
	0xa5, 0xe1, 0xde, 0x99, 0x19, 0xee, 0x7f, 0x05, 0x75, 0xfd, 0x96, 0x40, 0x7b, 0xe1, 0x2d, 0x3e,
	0x5e, 0x74, 0x8b, 0x7c, 0x63, 0xdf, 0x6a, 0x79, 0x7f, 0xaa, 0xc0, 0xda, 0x4b, 0xb4, 0x2d, 0x8f,
	0xcd, 0xa7, 0x6f, 0x41, 0x9d, 0x27, 0xa7, 0xb1, 0x18, 0xe8, 0xa3, 0x9a, 0xbe, 0x5d, 0x61, 0x1b,
	0xe8, 0x53, 0x71, 0x29, 0xa7, 0x13, 0x15, 0xde, 0xda, 0xd0, 0xb2, 0x6d, 0x20, 0xc7, 0x4d, 0xbb,
	0x5d, 0x34, 0xf6, 0xed, 0xc3, 0xe6, 0xc4, 0x1e, 0x87, 0x7e, 0x7f, 0x95, 0xf2, 0x4c, 0x13, 0x98,
	0x2b, 0x23, 0x5f, 0xc0, 0xd6, 0x9d, 0xd7, 0xd9, 0xb1, 0x50, 0x76, 0xaa, 0x69, 0xf9, 0xef, 0x90,
	0xe2, 0x55, 0x8c, 0x9b, 0x6d, 0x1e, 0xd9, 0x15, 0xd9, 0x06, 0x60, 0x48, 0x30, 0x03, 0x83, 0xa9,
	0xfc, 0x05, 0xc4, 0x93, 0x00, 0xb9, 0xa5, 0xfe, 0xbf, 0x7a, 0xf3, 0x13, 0x58, 0xc7, 0x92, 0x81,
	0xcf, 0xad, 0xb4, 0x92, 0x18, 0xa3, 0x75, 0x53, 0xd8, 0xd4, 0x12, 0x6f, 0x07, 0x40, 0x1f, 0x7e,
	0xca, 0xae, 0xd9, 0x88, 0xac, 0x81, 0x33, 0xb1, 0xae, 0x76, 0x26, 0xb8, 0xba, 0xb2, 0x6a, 0xce,
	0x95, 0xf7, 0x1d, 0x74, 0x8f, 0xed, 0xb9, 0x47, 0x31, 0x3e, 0xc7, 0xf1, 0x5d, 0x7b, 0xcd, 0x24,
	0xbf, 0xb8, 0xc5, 0x47, 0x70, 0x18, 0x0b, 0x25, 0x69, 0xa8, 0xac, 0xfa, 0x46, 0x26, 0xf9, 0xca,
	0x0a, 0x4a, 0xbd, 0xde, 0xec, 0x9a, 0xf6, 0x7a, 0xef, 0xcf, 0x15, 0xd8, 0x38, 0xe3, 0x03, 0xc1,
	0xa2, 0x73, 0x49, 0x45, 0x42, 0x43, 0xf4, 0x45, 0xd6, 0x63, 0x9c, 0x42, 0x8f, 0xc1, 0x66, 0x8b,
	0x44, 0x39, 0x33, 0x13, 0x74, 0x0c, 0x9a, 0x36, 0x5b, 0x02, 0x55, 0x5d, 0xf5, 0x4d, 0x18, 0xe8,
	0xdf, 0x8b, 0x5a, 0x5d, 0x75, 0x51, 0xab, 0x7b, 0x1f, 0x5a, 0x03, 0x9a, 0xd8, 0xd0, 0xb3, 0xff,
	0xba, 0x0c, 0x68, 0x62, 0x62, 0xee, 0x10, 0xea, 0x91, 0xb6, 0x86, 0xf6, 0x75, 0x7b, 0xff, 0xa7,
	0x8b, 0xdc, 0x54, 0xb6, 0x9f, 0x6f, 0x35, 0xcb, 0x1d, 0xa8, 0x31, 0xd3, 0x81, 0x0e, 0x87, 0x7f,
	0x7f, 0xb3, 0xed, 0xbc, 0x7e, 0xb3, 0xed, 0xfc, 0xe7, 0xcd, 0xb6, 0xf3, 0xc7, 0xb7, 0xdb, 0x2b,
	0xaf, 0xdf, 0x6e, 0xaf, 0xfc, 0xfb, 0xed, 0xf6, 0xca, 0x77, 0xbf, 0x1e, 0x70, 0x35, 0x9c, 0xf6,
	0x77, 0xc3, 0x78, 0xbc, 0x77, 0x92, 0x9e, 0x7a, 0x4a, 0xfb, 0xc9, 0x5e, 0xf6, 0x0d, 0x9f, 0x85,
	0xb1, 0x64, 0xc5, 0x25, 0x1a, 0x7c, 0x6f, 0x1c, 0x47, 0xd3, 0x11, 0x4b, 0xf2, 0x7f, 0xc8, 0xb0,
	0xa4, 0x27, 0xfd, 0xba, 0xfe, 0x97, 0xeb, 0xf3, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x24, 0x26,
	0x04, 0xa5, 0x44, 0x13, 0x00, 0x00,
}

func (m *DerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CumulativeFunding) > 0 {
		i -= len(m.CumulativeFunding)
		copy(dAtA[i:], m.CumulativeFunding)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.CumulativeFunding)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.FundingInterval) > 0 {
		i -= len(m.FundingInterval)
		copy(dAtA[i:], m.FundingInterval)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FundingInterval)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.NextFundingTimestamp) > 0 {
		i -= len(m.NextFundingTimestamp)
		copy(dAtA[i:], m.NextFundingTimestamp)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.NextFundingTimestamp)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.TakerTxFee) > 0 {
		i -= len(m.TakerTxFee)
		copy(dAtA[i:], m.TakerTxFee)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TakerTxFee)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.MakerTxFee) > 0 {
		i -= len(m.MakerTxFee)
		copy(dAtA[i:], m.MakerTxFee)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MakerTxFee)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.MaintenanceMarginRatio) > 0 {
		i -= len(m.MaintenanceMarginRatio)
		copy(dAtA[i:], m.MaintenanceMarginRatio)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MaintenanceMarginRatio)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.InitialMarginRatio) > 0 {
		i -= len(m.InitialMarginRatio)
		copy(dAtA[i:], m.InitialMarginRatio)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.InitialMarginRatio)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.IndexPrice) > 0 {
		i -= len(m.IndexPrice)
		copy(dAtA[i:], m.IndexPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.IndexPrice)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PriceFactor) > 0 {
		i -= len(m.PriceFactor)
		copy(dAtA[i:], m.PriceFactor)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.PriceFactor)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Oracle) > 0 {
		i -= len(m.Oracle)
		copy(dAtA[i:], m.Oracle)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Oracle)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x42
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TakerTxFee) > 0 {
		i -= len(m.TakerTxFee)
		copy(dAtA[i:], m.TakerTxFee)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TakerTxFee)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MakerTxFee) > 0 {
		i -= len(m.MakerTxFee)
		copy(dAtA[i:], m.MakerTxFee)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MakerTxFee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QuoteAsset) > 0 {
		i -= len(m.QuoteAsset)
		copy(dAtA[i:], m.QuoteAsset)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.QuoteAsset)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BaseAsset) > 0 {
		i -= len(m.BaseAsset)
		copy(dAtA[i:], m.BaseAsset)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.BaseAsset)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TriggerPrice) > 0 {
		i -= len(m.TriggerPrice)
		copy(dAtA[i:], m.TriggerPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TriggerPrice)))
		i--
		dAtA[i] = 0x52
	}
	if m.OrderType != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.OrderType))
		i--
		dAtA[i] = 0x48
	}
	if m.CreationBlockHeight != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.CreationBlockHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.FilledAmount) > 0 {
		i -= len(m.FilledAmount)
		copy(dAtA[i:], m.FilledAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FilledAmount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DemandAmount) > 0 {
		i -= len(m.DemandAmount)
		copy(dAtA[i:], m.DemandAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.DemandAmount)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SupplyAmount) > 0 {
		i -= len(m.SupplyAmount)
		copy(dAtA[i:], m.SupplyAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SupplyAmount)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Expiry != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FeeRecipient) > 0 {
		i -= len(m.FeeRecipient)
		copy(dAtA[i:], m.FeeRecipient)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FeeRecipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotMarketOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarketOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarketOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TriggerPrice) > 0 {
		i -= len(m.TriggerPrice)
		copy(dAtA[i:], m.TriggerPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TriggerPrice)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrderType != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.OrderType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FundsSupplied) > 0 {
		i -= len(m.FundsSupplied)
		copy(dAtA[i:], m.FundsSupplied)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FundsSupplied)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FeeRecipient) > 0 {
		i -= len(m.FeeRecipient)
		copy(dAtA[i:], m.FeeRecipient)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FeeRecipient)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TriggerPrice) > 0 {
		i -= len(m.TriggerPrice)
		copy(dAtA[i:], m.TriggerPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TriggerPrice)))
		i--
		dAtA[i] = 0x5a
	}
	if m.OrderType != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.OrderType))
		i--
		dAtA[i] = 0x50
	}
	if m.Salt != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.Salt))
		i--
		dAtA[i] = 0x48
	}
	if len(m.DemandAmount) > 0 {
		i -= len(m.DemandAmount)
		copy(dAtA[i:], m.DemandAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.DemandAmount)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SupplyAmount) > 0 {
		i -= len(m.SupplyAmount)
		copy(dAtA[i:], m.SupplyAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SupplyAmount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MarketID) > 0 {
		i -= len(m.MarketID)
		copy(dAtA[i:], m.MarketID)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MarketID)))
		i--
		dAtA[i] = 0x32
	}
	if m.Expiry != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FeeRecipient) > 0 {
		i -= len(m.FeeRecipient)
		copy(dAtA[i:], m.FeeRecipient)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FeeRecipient)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintExchange(dAtA, i, uint64((uint64(m.ChainId)<<1)^uint64((m.ChainId>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BaseOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TakerFeeAssetData) > 0 {
		i -= len(m.TakerFeeAssetData)
		copy(dAtA[i:], m.TakerFeeAssetData)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TakerFeeAssetData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.MakerFeeAssetData) > 0 {
		i -= len(m.MakerFeeAssetData)
		copy(dAtA[i:], m.MakerFeeAssetData)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MakerFeeAssetData)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TakerFee) > 0 {
		i -= len(m.TakerFee)
		copy(dAtA[i:], m.TakerFee)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TakerFee)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MakerFee) > 0 {
		i -= len(m.MakerFee)
		copy(dAtA[i:], m.MakerFee)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MakerFee)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TakerAssetAmount) > 0 {
		i -= len(m.TakerAssetAmount)
		copy(dAtA[i:], m.TakerAssetAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TakerAssetAmount)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MakerAssetAmount) > 0 {
		i -= len(m.MakerAssetAmount)
		copy(dAtA[i:], m.MakerAssetAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MakerAssetAmount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SenderAddress) > 0 {
		i -= len(m.SenderAddress)
		copy(dAtA[i:], m.SenderAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SenderAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TakerAddress) > 0 {
		i -= len(m.TakerAddress)
		copy(dAtA[i:], m.TakerAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TakerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintExchange(dAtA, i, uint64((uint64(m.ChainId)<<1)^uint64((m.ChainId>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TriggerPrice) > 0 {
		i -= len(m.TriggerPrice)
		copy(dAtA[i:], m.TriggerPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TriggerPrice)))
		i--
		dAtA[i] = 0x42
	}
	if m.OrderType != 0 {
		i = encodeVarintExchange(dAtA, i, uint64(m.OrderType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IndexPriceRequirement) > 0 {
		i -= len(m.IndexPriceRequirement)
		copy(dAtA[i:], m.IndexPriceRequirement)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.IndexPriceRequirement)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintExchange(dAtA, i, uint64((uint64(m.Status)<<1)^uint64((m.Status>>63))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FilledAmount) > 0 {
		i -= len(m.FilledAmount)
		copy(dAtA[i:], m.FilledAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FilledAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradePairHash) > 0 {
		i -= len(m.TradePairHash)
		copy(dAtA[i:], m.TradePairHash)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TradePairHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExchange(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarginInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarginInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarginInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalDeposits) > 0 {
		i -= len(m.TotalDeposits)
		copy(dAtA[i:], m.TotalDeposits)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TotalDeposits)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarginHold) > 0 {
		i -= len(m.MarginHold)
		copy(dAtA[i:], m.MarginHold)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MarginHold)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseCurrencyMarginInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseCurrencyMarginInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseCurrencyMarginInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TotalDeposits) > 0 {
		i -= len(m.TotalDeposits)
		copy(dAtA[i:], m.TotalDeposits)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.TotalDeposits)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarginHold) > 0 {
		i -= len(m.MarginHold)
		copy(dAtA[i:], m.MarginHold)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MarginHold)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubaccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BaseCurrencyMarginInfo) > 0 {
		for iNdEx := len(m.BaseCurrencyMarginInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BaseCurrencyMarginInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExchange(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderQuoteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderQuoteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderQuoteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Quotes) > 0 {
		for iNdEx := len(m.Quotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Quotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExchange(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EntryPrice) > 0 {
		i -= len(m.EntryPrice)
		copy(dAtA[i:], m.EntryPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.EntryPrice)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Margin) > 0 {
		i -= len(m.Margin)
		copy(dAtA[i:], m.Margin)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Margin)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CumulativeFundingEntry) > 0 {
		i -= len(m.CumulativeFundingEntry)
		copy(dAtA[i:], m.CumulativeFundingEntry)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.CumulativeFundingEntry)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PositionHoldQuantity) > 0 {
		i -= len(m.PositionHoldQuantity)
		copy(dAtA[i:], m.PositionHoldQuantity)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.PositionHoldQuantity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BankruptcyPrice) > 0 {
		i -= len(m.BankruptcyPrice)
		copy(dAtA[i:], m.BankruptcyPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.BankruptcyPrice)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsLong {
		i--
		if m.IsLong {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderQuote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderQuote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderQuote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FillableAmount) > 0 {
		i -= len(m.FillableAmount)
		copy(dAtA[i:], m.FillableAmount)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.FillableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExchange(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PriceLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Q) > 0 {
		i -= len(m.Q)
		copy(dAtA[i:], m.Q)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Q)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.P) > 0 {
		i -= len(m.P)
		copy(dAtA[i:], m.P)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.P)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerifyingContract) > 0 {
		i -= len(m.VerifyingContract)
		copy(dAtA[i:], m.VerifyingContract)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.VerifyingContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExchange(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.GasPrice) > 0 {
		i -= len(m.GasPrice)
		copy(dAtA[i:], m.GasPrice)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.GasPrice)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SignerAddress) > 0 {
		i -= len(m.SignerAddress)
		copy(dAtA[i:], m.SignerAddress)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.SignerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintExchange(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintExchange(dAtA []byte, offset int, v uint64) int {
	offset -= sovExchange(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Oracle)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.PriceFactor)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.IndexPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.InitialMarginRatio)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MaintenanceMarginRatio)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MakerTxFee)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TakerTxFee)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.NextFundingTimestamp)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FundingInterval)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.CumulativeFunding)
	if l > 0 {
		n += 2 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *SpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.BaseAsset)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.QuoteAsset)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MakerTxFee)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TakerTxFee)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *SpotLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FeeRecipient)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovExchange(uint64(m.Expiry))
	}
	l = len(m.SupplyAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.DemandAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FilledAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.CreationBlockHeight != 0 {
		n += 1 + sovExchange(uint64(m.CreationBlockHeight))
	}
	if m.OrderType != 0 {
		n += 1 + sovExchange(uint64(m.OrderType))
	}
	l = len(m.TriggerPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *SpotMarketOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FeeRecipient)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FundsSupplied)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.OrderType != 0 {
		n += 1 + sovExchange(uint64(m.OrderType))
	}
	l = len(m.TriggerPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *BaseSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sozExchange(uint64(m.ChainId))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FeeRecipient)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovExchange(uint64(m.Expiry))
	}
	l = len(m.MarketID)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.SupplyAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.DemandAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.Salt != 0 {
		n += 1 + sovExchange(uint64(m.Salt))
	}
	if m.OrderType != 0 {
		n += 1 + sovExchange(uint64(m.OrderType))
	}
	l = len(m.TriggerPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *BaseOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sozExchange(uint64(m.ChainId))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TakerAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.SenderAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MakerFee)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TakerFee)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.MakerFeeAssetData)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TakerFeeAssetData)
	if l > 0 {
		n += 2 + l + sovExchange(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 2 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TradePairHash)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FilledAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sozExchange(uint64(m.Status))
	}
	l = len(m.IndexPriceRequirement)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.OrderType != 0 {
		n += 1 + sovExchange(uint64(m.OrderType))
	}
	l = len(m.TriggerPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *MarginInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarginHold)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TotalDeposits)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *BaseCurrencyMarginInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarginHold)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.TotalDeposits)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *SubaccountInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BaseCurrencyMarginInfo) > 0 {
		for _, e := range m.BaseCurrencyMarginInfo {
			l = e.Size()
			n += 1 + l + sovExchange(uint64(l))
		}
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *OrderQuoteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if len(m.Quotes) > 0 {
		for _, e := range m.Quotes {
			l = e.Size()
			n += 1 + l + sovExchange(uint64(l))
		}
	}
	return n
}

func (m *PositionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsLong {
		n += 2
	}
	l = len(m.BankruptcyPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.PositionHoldQuantity)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.CumulativeFundingEntry)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Margin)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.EntryPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *OrderQuote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.FillableAmount)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *PriceLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.P)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *ExchangeDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerifyingContract)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func (m *SignedTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.SignerAddress)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovExchange(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovExchange(uint64(l))
	}
	return n
}

func sovExchange(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExchange(x uint64) (n int) {
	return sovExchange(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oracle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceFactor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialMarginRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintenanceMarginRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerTxFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerTxFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerTxFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerTxFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextFundingTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextFundingTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeFunding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeFunding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseAsset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteAsset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerTxFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerTxFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerTxFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerTxFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DemandAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DemandAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationBlockHeight", wireType)
			}
			m.CreationBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= SpotLimitOrder_LimitOrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotMarketOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarketOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarketOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundsSupplied", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundsSupplied = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= SpotMarketOrder_MarketOrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ChainId = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DemandAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DemandAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= BaseSpotOrder_OrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ChainId = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradePairHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradePairHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Status = int64(v)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPriceRequirement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexPriceRequirement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarginInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarginInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginHold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginHold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDeposits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseCurrencyMarginInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseCurrencyMarginInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseCurrencyMarginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginHold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginHold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDeposits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrencyMarginInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrencyMarginInfo = append(m.BaseCurrencyMarginInfo, &BaseCurrencyMarginInfo{})
			if err := m.BaseCurrencyMarginInfo[len(m.BaseCurrencyMarginInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderQuoteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderQuoteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderQuoteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quotes = append(m.Quotes, &OrderQuote{})
			if err := m.Quotes[len(m.Quotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLong", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLong = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankruptcyPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankruptcyPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionHoldQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionHoldQuantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeFundingEntry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeFundingEntry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Margin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderQuote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderQuote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderQuote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FillableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyingContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyingContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &ExchangeDomain{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExchange
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExchange
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExchange(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExchange
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExchange(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExchange
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExchange
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExchange
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupExchange
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthExchange
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthExchange        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExchange          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupExchange = fmt.Errorf("proto: unexpected end of group")
)
