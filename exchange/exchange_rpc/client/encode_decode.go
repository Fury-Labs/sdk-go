// Code generated by goa v3.3.1, DO NOT EDIT.
//
// InjectiveExchangeRPC gRPC client encoders and decoders
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-exchange/api/design -o ../

package client

import (
	"context"

	injective_exchange_rpcpb "github.com/InjectiveLabs/injective-exchange/api/gen/grpc/injective_exchange_rpc/pb"
	injectiveexchangerpc "github.com/InjectiveLabs/injective-exchange/api/gen/injective_exchange_rpc"
	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildPingFunc builds the remote method to invoke for "InjectiveExchangeRPC"
// service "ping" endpoint.
func BuildPingFunc(grpccli injective_exchange_rpcpb.InjectiveExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Ping(ctx, reqpb.(*injective_exchange_rpcpb.PingRequest), opts...)
		}
		return grpccli.Ping(ctx, &injective_exchange_rpcpb.PingRequest{}, opts...)
	}
}

// BuildVersionFunc builds the remote method to invoke for
// "InjectiveExchangeRPC" service "version" endpoint.
func BuildVersionFunc(grpccli injective_exchange_rpcpb.InjectiveExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Version(ctx, reqpb.(*injective_exchange_rpcpb.VersionRequest), opts...)
		}
		return grpccli.Version(ctx, &injective_exchange_rpcpb.VersionRequest{}, opts...)
	}
}

// DecodeVersionResponse decodes responses from the InjectiveExchangeRPC
// version endpoint.
func DecodeVersionResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_exchange_rpcpb.VersionResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveExchangeRPC", "version", "*injective_exchange_rpcpb.VersionResponse", v)
	}
	res := NewVersionResult(message)
	return res, nil
}

// BuildGetTxFunc builds the remote method to invoke for "InjectiveExchangeRPC"
// service "getTx" endpoint.
func BuildGetTxFunc(grpccli injective_exchange_rpcpb.InjectiveExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetTx(ctx, reqpb.(*injective_exchange_rpcpb.GetTxRequest), opts...)
		}
		return grpccli.GetTx(ctx, &injective_exchange_rpcpb.GetTxRequest{}, opts...)
	}
}

// EncodeGetTxRequest encodes requests sent to InjectiveExchangeRPC getTx
// endpoint.
func EncodeGetTxRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveexchangerpc.GetTxPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveExchangeRPC", "getTx", "*injectiveexchangerpc.GetTxPayload", v)
	}
	return NewGetTxRequest(payload), nil
}

// DecodeGetTxResponse decodes responses from the InjectiveExchangeRPC getTx
// endpoint.
func DecodeGetTxResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_exchange_rpcpb.GetTxResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveExchangeRPC", "getTx", "*injective_exchange_rpcpb.GetTxResponse", v)
	}
	if err := ValidateGetTxResponse(message); err != nil {
		return nil, err
	}
	res := NewGetTxResult(message)
	return res, nil
}

// BuildPrepareTxFunc builds the remote method to invoke for
// "InjectiveExchangeRPC" service "prepareTx" endpoint.
func BuildPrepareTxFunc(grpccli injective_exchange_rpcpb.InjectiveExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.PrepareTx(ctx, reqpb.(*injective_exchange_rpcpb.PrepareTxRequest), opts...)
		}
		return grpccli.PrepareTx(ctx, &injective_exchange_rpcpb.PrepareTxRequest{}, opts...)
	}
}

// EncodePrepareTxRequest encodes requests sent to InjectiveExchangeRPC
// prepareTx endpoint.
func EncodePrepareTxRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveexchangerpc.PrepareTxPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveExchangeRPC", "prepareTx", "*injectiveexchangerpc.PrepareTxPayload", v)
	}
	return NewPrepareTxRequest(payload), nil
}

// DecodePrepareTxResponse decodes responses from the InjectiveExchangeRPC
// prepareTx endpoint.
func DecodePrepareTxResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_exchange_rpcpb.PrepareTxResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveExchangeRPC", "prepareTx", "*injective_exchange_rpcpb.PrepareTxResponse", v)
	}
	res := NewPrepareTxResult(message)
	return res, nil
}

// BuildBroadcastTxFunc builds the remote method to invoke for
// "InjectiveExchangeRPC" service "broadcastTx" endpoint.
func BuildBroadcastTxFunc(grpccli injective_exchange_rpcpb.InjectiveExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.BroadcastTx(ctx, reqpb.(*injective_exchange_rpcpb.BroadcastTxRequest), opts...)
		}
		return grpccli.BroadcastTx(ctx, &injective_exchange_rpcpb.BroadcastTxRequest{}, opts...)
	}
}

// EncodeBroadcastTxRequest encodes requests sent to InjectiveExchangeRPC
// broadcastTx endpoint.
func EncodeBroadcastTxRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveexchangerpc.BroadcastTxPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveExchangeRPC", "broadcastTx", "*injectiveexchangerpc.BroadcastTxPayload", v)
	}
	return NewBroadcastTxRequest(payload), nil
}

// DecodeBroadcastTxResponse decodes responses from the InjectiveExchangeRPC
// broadcastTx endpoint.
func DecodeBroadcastTxResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_exchange_rpcpb.BroadcastTxResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveExchangeRPC", "broadcastTx", "*injective_exchange_rpcpb.BroadcastTxResponse", v)
	}
	if err := ValidateBroadcastTxResponse(message); err != nil {
		return nil, err
	}
	res := NewBroadcastTxResult(message)
	return res, nil
}
