// Code generated by goa v3.3.1, DO NOT EDIT.
//
// InjectiveExchangeRPC gRPC client types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-exchange/api/design -o ../

package client

import (
	injective_exchange_rpcpb "github.com/InjectiveLabs/injective-exchange/api/gen/grpc/injective_exchange_rpc/pb"
	injectiveexchangerpc "github.com/InjectiveLabs/injective-exchange/api/gen/injective_exchange_rpc"
	goa "goa.design/goa/v3/pkg"
)

// NewPingRequest builds the gRPC request type from the payload of the "ping"
// endpoint of the "InjectiveExchangeRPC" service.
func NewPingRequest() *injective_exchange_rpcpb.PingRequest {
	message := &injective_exchange_rpcpb.PingRequest{}
	return message
}

// NewVersionRequest builds the gRPC request type from the payload of the
// "version" endpoint of the "InjectiveExchangeRPC" service.
func NewVersionRequest() *injective_exchange_rpcpb.VersionRequest {
	message := &injective_exchange_rpcpb.VersionRequest{}
	return message
}

// NewVersionResult builds the result type of the "version" endpoint of the
// "InjectiveExchangeRPC" service from the gRPC response type.
func NewVersionResult(message *injective_exchange_rpcpb.VersionResponse) *injectiveexchangerpc.VersionResult {
	result := &injectiveexchangerpc.VersionResult{
		Version: message.Version,
	}
	if message.MetaData != nil {
		result.MetaData = make(map[string]string, len(message.MetaData))
		for key, val := range message.MetaData {
			tk := key
			tv := val
			result.MetaData[tk] = tv
		}
	}
	return result
}

// NewGetTxRequest builds the gRPC request type from the payload of the "getTx"
// endpoint of the "InjectiveExchangeRPC" service.
func NewGetTxRequest(payload *injectiveexchangerpc.GetTxPayload) *injective_exchange_rpcpb.GetTxRequest {
	message := &injective_exchange_rpcpb.GetTxRequest{
		Hash: payload.Hash,
	}
	return message
}

// NewGetTxResult builds the result type of the "getTx" endpoint of the
// "InjectiveExchangeRPC" service from the gRPC response type.
func NewGetTxResult(message *injective_exchange_rpcpb.GetTxResponse) *injectiveexchangerpc.TxResult {
	result := &injectiveexchangerpc.TxResult{
		TxHash:    message.TxHash,
		Codespace: message.Codespace,
		Code:      message.Code,
		Data:      message.Data,
		RawLog:    message.RawLog,
	}
	if message.Height != 0 {
		result.Height = &message.Height
	}
	if message.Index != 0 {
		result.Index = &message.Index
	}
	if message.Timestamp != "" {
		result.Timestamp = &message.Timestamp
	}
	return result
}

// NewPrepareTxRequest builds the gRPC request type from the payload of the
// "prepareTx" endpoint of the "InjectiveExchangeRPC" service.
func NewPrepareTxRequest(payload *injectiveexchangerpc.PrepareTxPayload) *injective_exchange_rpcpb.PrepareTxRequest {
	message := &injective_exchange_rpcpb.PrepareTxRequest{
		ChainId:       payload.ChainID,
		SignerAddress: payload.SignerAddress,
	}
	if payload.Sequence != nil {
		message.Sequence = *payload.Sequence
	}
	if payload.Memo != nil {
		message.Memo = *payload.Memo
	}
	if payload.TimeoutHeight != nil {
		message.TimeoutHeight = *payload.TimeoutHeight
	}
	if payload.Fee != nil {
		message.Fee = svcInjectiveexchangerpcCosmosTxFeeToInjectiveExchangeRpcpbCosmosTxFee(payload.Fee)
	}
	if payload.Msgs != nil {
		message.Msgs = make([][]byte, len(payload.Msgs))
		for i, val := range payload.Msgs {
			message.Msgs[i] = val
		}
	}
	return message
}

// NewPrepareTxResult builds the result type of the "prepareTx" endpoint of the
// "InjectiveExchangeRPC" service from the gRPC response type.
func NewPrepareTxResult(message *injective_exchange_rpcpb.PrepareTxResponse) *injectiveexchangerpc.PrepareTxResult {
	result := &injectiveexchangerpc.PrepareTxResult{
		Data:       message.Data,
		Sequence:   message.Sequence,
		SignMode:   message.SignMode,
		PubKeyType: message.PubKeyType,
	}
	return result
}

// NewBroadcastTxRequest builds the gRPC request type from the payload of the
// "broadcastTx" endpoint of the "InjectiveExchangeRPC" service.
func NewBroadcastTxRequest(payload *injectiveexchangerpc.BroadcastTxPayload) *injective_exchange_rpcpb.BroadcastTxRequest {
	message := &injective_exchange_rpcpb.BroadcastTxRequest{
		ChainId:   payload.ChainID,
		Tx:        payload.Tx,
		Signature: payload.Signature,
		Mode:      payload.Mode,
	}
	if payload.Msgs != nil {
		message.Msgs = make([][]byte, len(payload.Msgs))
		for i, val := range payload.Msgs {
			message.Msgs[i] = val
		}
	}
	if payload.PubKey != nil {
		message.PubKey = svcInjectiveexchangerpcCosmosPubKeyToInjectiveExchangeRpcpbCosmosPubKey(payload.PubKey)
	}
	return message
}

// NewBroadcastTxResult builds the result type of the "broadcastTx" endpoint of
// the "InjectiveExchangeRPC" service from the gRPC response type.
func NewBroadcastTxResult(message *injective_exchange_rpcpb.BroadcastTxResponse) *injectiveexchangerpc.TxResult {
	result := &injectiveexchangerpc.TxResult{
		TxHash:    message.TxHash,
		Codespace: message.Codespace,
		Code:      message.Code,
		Data:      message.Data,
		RawLog:    message.RawLog,
	}
	if message.Height != 0 {
		result.Height = &message.Height
	}
	if message.Index != 0 {
		result.Index = &message.Index
	}
	if message.Timestamp != "" {
		result.Timestamp = &message.Timestamp
	}
	return result
}

// ValidateGetTxResponse runs the validations defined on GetTxResponse.
func ValidateGetTxResponse(message *injective_exchange_rpcpb.GetTxResponse) (err error) {
	if message.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "message"))
	}
	return
}

// ValidateBroadcastTxResponse runs the validations defined on
// BroadcastTxResponse.
func ValidateBroadcastTxResponse(message *injective_exchange_rpcpb.BroadcastTxResponse) (err error) {
	if message.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "message"))
	}
	return
}

// protobufInjectiveExchangeRpcpbCosmosTxFeeToInjectiveexchangerpcCosmosTxFee
// builds a value of type *injectiveexchangerpc.CosmosTxFee from a value of
// type *injective_exchange_rpcpb.CosmosTxFee.
func protobufInjectiveExchangeRpcpbCosmosTxFeeToInjectiveexchangerpcCosmosTxFee(v *injective_exchange_rpcpb.CosmosTxFee) *injectiveexchangerpc.CosmosTxFee {
	res := &injectiveexchangerpc.CosmosTxFee{
		Gas: v.Gas,
	}
	if v.Amounts != nil {
		res.Amounts = make([]*injectiveexchangerpc.CosmosCoin, len(v.Amounts))
		for i, val := range v.Amounts {
			res.Amounts[i] = &injectiveexchangerpc.CosmosCoin{
				Denom:  val.Denom,
				Amount: val.Amount,
			}
		}
	}

	return res
}

// svcInjectiveexchangerpcCosmosTxFeeToInjectiveExchangeRpcpbCosmosTxFee builds
// a value of type *injective_exchange_rpcpb.CosmosTxFee from a value of type
// *injectiveexchangerpc.CosmosTxFee.
func svcInjectiveexchangerpcCosmosTxFeeToInjectiveExchangeRpcpbCosmosTxFee(v *injectiveexchangerpc.CosmosTxFee) *injective_exchange_rpcpb.CosmosTxFee {
	res := &injective_exchange_rpcpb.CosmosTxFee{
		Gas: v.Gas,
	}
	if v.Amounts != nil {
		res.Amounts = make([]*injective_exchange_rpcpb.CosmosCoin, len(v.Amounts))
		for i, val := range v.Amounts {
			res.Amounts[i] = &injective_exchange_rpcpb.CosmosCoin{
				Denom:  val.Denom,
				Amount: val.Amount,
			}
		}
	}

	return res
}

// protobufInjectiveExchangeRpcpbCosmosPubKeyToInjectiveexchangerpcCosmosPubKey
// builds a value of type *injectiveexchangerpc.CosmosPubKey from a value of
// type *injective_exchange_rpcpb.CosmosPubKey.
func protobufInjectiveExchangeRpcpbCosmosPubKeyToInjectiveexchangerpcCosmosPubKey(v *injective_exchange_rpcpb.CosmosPubKey) *injectiveexchangerpc.CosmosPubKey {
	res := &injectiveexchangerpc.CosmosPubKey{
		Type: v.Type,
		Key:  v.Key,
	}

	return res
}

// svcInjectiveexchangerpcCosmosPubKeyToInjectiveExchangeRpcpbCosmosPubKey
// builds a value of type *injective_exchange_rpcpb.CosmosPubKey from a value
// of type *injectiveexchangerpc.CosmosPubKey.
func svcInjectiveexchangerpcCosmosPubKeyToInjectiveExchangeRpcpbCosmosPubKey(v *injectiveexchangerpc.CosmosPubKey) *injective_exchange_rpcpb.CosmosPubKey {
	res := &injective_exchange_rpcpb.CosmosPubKey{
		Type: v.Type,
		Key:  v.Key,
	}

	return res
}
