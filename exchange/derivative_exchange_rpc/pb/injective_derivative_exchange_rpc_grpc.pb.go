// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: kaiju_derivative_exchange_rpc.proto

package kaiju_derivative_exchange_rpcpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// KaijuDerivativeExchangeRPCClient is the client API for KaijuDerivativeExchangeRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KaijuDerivativeExchangeRPCClient interface {
	// Markets gets a list of Derivative Markets
	Markets(ctx context.Context, in *MarketsRequest, opts ...grpc.CallOption) (*MarketsResponse, error)
	// Market gets details of a single derivative market
	Market(ctx context.Context, in *MarketRequest, opts ...grpc.CallOption) (*MarketResponse, error)
	// StreamMarket streams live updates of selected derivative markets
	StreamMarket(ctx context.Context, in *StreamMarketRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamMarketClient, error)
	// BinaryOptionsMarkets gets a list of Binary Options Markets
	BinaryOptionsMarkets(ctx context.Context, in *BinaryOptionsMarketsRequest, opts ...grpc.CallOption) (*BinaryOptionsMarketsResponse, error)
	// BinaryOptionMarket gets details of a single binary options market
	BinaryOptionsMarket(ctx context.Context, in *BinaryOptionsMarketRequest, opts ...grpc.CallOption) (*BinaryOptionsMarketResponse, error)
	// Orderbook gets the Orderbook of a Derivative Market
	Orderbook(ctx context.Context, in *OrderbookRequest, opts ...grpc.CallOption) (*OrderbookResponse, error)
	// Orderbooks gets the Orderbooks of requested derivative markets
	Orderbooks(ctx context.Context, in *OrderbooksRequest, opts ...grpc.CallOption) (*OrderbooksResponse, error)
	// Stream live snapshot updates of selected derivative market orderbook
	StreamOrderbookSnapshot(ctx context.Context, in *StreamOrderbookSnapshotRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrderbookSnapshotClient, error)
	// Stream live level updates of selected derivative market orderbook
	StreamOrderbookUpdate(ctx context.Context, in *StreamOrderbookUpdateRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrderbookUpdateClient, error)
	// DerivativeLimitOrders gets the limit orders of a Derivative Market.
	Orders(ctx context.Context, in *OrdersRequest, opts ...grpc.CallOption) (*OrdersResponse, error)
	// Positions gets the positions for a trader.
	Positions(ctx context.Context, in *PositionsRequest, opts ...grpc.CallOption) (*PositionsResponse, error)
	// LiquidablePositions gets all the liquidable positions.
	LiquidablePositions(ctx context.Context, in *LiquidablePositionsRequest, opts ...grpc.CallOption) (*LiquidablePositionsResponse, error)
	// FundingPayments gets the funding payments for a trader.
	FundingPayments(ctx context.Context, in *FundingPaymentsRequest, opts ...grpc.CallOption) (*FundingPaymentsResponse, error)
	// FundingRates gets the historical funding rates for a market.
	FundingRates(ctx context.Context, in *FundingRatesRequest, opts ...grpc.CallOption) (*FundingRatesResponse, error)
	// StreamPositions streams derivatives position updates.
	StreamPositions(ctx context.Context, in *StreamPositionsRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamPositionsClient, error)
	// StreamOrders streams updates to individual orders of a Derivative Market.
	StreamOrders(ctx context.Context, in *StreamOrdersRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrdersClient, error)
	// Trades gets the trades of a Derivative Market.
	Trades(ctx context.Context, in *TradesRequest, opts ...grpc.CallOption) (*TradesResponse, error)
	// StreamTrades streams newly executed trades from Derivative Market.
	StreamTrades(ctx context.Context, in *StreamTradesRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamTradesClient, error)
	// SubaccountOrdersList lists orders posted from this subaccount.
	SubaccountOrdersList(ctx context.Context, in *SubaccountOrdersListRequest, opts ...grpc.CallOption) (*SubaccountOrdersListResponse, error)
	// SubaccountTradesList gets a list of derivatives trades executed by this
	// subaccount.
	SubaccountTradesList(ctx context.Context, in *SubaccountTradesListRequest, opts ...grpc.CallOption) (*SubaccountTradesListResponse, error)
	// Lists history orders posted from a subaccount
	OrdersHistory(ctx context.Context, in *OrdersHistoryRequest, opts ...grpc.CallOption) (*OrdersHistoryResponse, error)
	// Stream updates to historical orders of a derivative Market
	StreamOrdersHistory(ctx context.Context, in *StreamOrdersHistoryRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrdersHistoryClient, error)
}

type kaijuDerivativeExchangeRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewKaijuDerivativeExchangeRPCClient(cc grpc.ClientConnInterface) KaijuDerivativeExchangeRPCClient {
	return &kaijuDerivativeExchangeRPCClient{cc}
}

func (c *kaijuDerivativeExchangeRPCClient) Markets(ctx context.Context, in *MarketsRequest, opts ...grpc.CallOption) (*MarketsResponse, error) {
	out := new(MarketsResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Markets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) Market(ctx context.Context, in *MarketRequest, opts ...grpc.CallOption) (*MarketResponse, error) {
	out := new(MarketResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Market", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) StreamMarket(ctx context.Context, in *StreamMarketRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamMarketClient, error) {
	stream, err := c.cc.NewStream(ctx, &KaijuDerivativeExchangeRPC_ServiceDesc.Streams[0], "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/StreamMarket", opts...)
	if err != nil {
		return nil, err
	}
	x := &kaijuDerivativeExchangeRPCStreamMarketClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KaijuDerivativeExchangeRPC_StreamMarketClient interface {
	Recv() (*StreamMarketResponse, error)
	grpc.ClientStream
}

type kaijuDerivativeExchangeRPCStreamMarketClient struct {
	grpc.ClientStream
}

func (x *kaijuDerivativeExchangeRPCStreamMarketClient) Recv() (*StreamMarketResponse, error) {
	m := new(StreamMarketResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kaijuDerivativeExchangeRPCClient) BinaryOptionsMarkets(ctx context.Context, in *BinaryOptionsMarketsRequest, opts ...grpc.CallOption) (*BinaryOptionsMarketsResponse, error) {
	out := new(BinaryOptionsMarketsResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/BinaryOptionsMarkets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) BinaryOptionsMarket(ctx context.Context, in *BinaryOptionsMarketRequest, opts ...grpc.CallOption) (*BinaryOptionsMarketResponse, error) {
	out := new(BinaryOptionsMarketResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/BinaryOptionsMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) Orderbook(ctx context.Context, in *OrderbookRequest, opts ...grpc.CallOption) (*OrderbookResponse, error) {
	out := new(OrderbookResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Orderbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) Orderbooks(ctx context.Context, in *OrderbooksRequest, opts ...grpc.CallOption) (*OrderbooksResponse, error) {
	out := new(OrderbooksResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Orderbooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) StreamOrderbookSnapshot(ctx context.Context, in *StreamOrderbookSnapshotRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrderbookSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &KaijuDerivativeExchangeRPC_ServiceDesc.Streams[1], "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/StreamOrderbookSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &kaijuDerivativeExchangeRPCStreamOrderbookSnapshotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KaijuDerivativeExchangeRPC_StreamOrderbookSnapshotClient interface {
	Recv() (*StreamOrderbookSnapshotResponse, error)
	grpc.ClientStream
}

type kaijuDerivativeExchangeRPCStreamOrderbookSnapshotClient struct {
	grpc.ClientStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrderbookSnapshotClient) Recv() (*StreamOrderbookSnapshotResponse, error) {
	m := new(StreamOrderbookSnapshotResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kaijuDerivativeExchangeRPCClient) StreamOrderbookUpdate(ctx context.Context, in *StreamOrderbookUpdateRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrderbookUpdateClient, error) {
	stream, err := c.cc.NewStream(ctx, &KaijuDerivativeExchangeRPC_ServiceDesc.Streams[2], "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/StreamOrderbookUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &kaijuDerivativeExchangeRPCStreamOrderbookUpdateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KaijuDerivativeExchangeRPC_StreamOrderbookUpdateClient interface {
	Recv() (*StreamOrderbookUpdateResponse, error)
	grpc.ClientStream
}

type kaijuDerivativeExchangeRPCStreamOrderbookUpdateClient struct {
	grpc.ClientStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrderbookUpdateClient) Recv() (*StreamOrderbookUpdateResponse, error) {
	m := new(StreamOrderbookUpdateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kaijuDerivativeExchangeRPCClient) Orders(ctx context.Context, in *OrdersRequest, opts ...grpc.CallOption) (*OrdersResponse, error) {
	out := new(OrdersResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Orders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) Positions(ctx context.Context, in *PositionsRequest, opts ...grpc.CallOption) (*PositionsResponse, error) {
	out := new(PositionsResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Positions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) LiquidablePositions(ctx context.Context, in *LiquidablePositionsRequest, opts ...grpc.CallOption) (*LiquidablePositionsResponse, error) {
	out := new(LiquidablePositionsResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/LiquidablePositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) FundingPayments(ctx context.Context, in *FundingPaymentsRequest, opts ...grpc.CallOption) (*FundingPaymentsResponse, error) {
	out := new(FundingPaymentsResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/FundingPayments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) FundingRates(ctx context.Context, in *FundingRatesRequest, opts ...grpc.CallOption) (*FundingRatesResponse, error) {
	out := new(FundingRatesResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/FundingRates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) StreamPositions(ctx context.Context, in *StreamPositionsRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamPositionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &KaijuDerivativeExchangeRPC_ServiceDesc.Streams[3], "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/StreamPositions", opts...)
	if err != nil {
		return nil, err
	}
	x := &kaijuDerivativeExchangeRPCStreamPositionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KaijuDerivativeExchangeRPC_StreamPositionsClient interface {
	Recv() (*StreamPositionsResponse, error)
	grpc.ClientStream
}

type kaijuDerivativeExchangeRPCStreamPositionsClient struct {
	grpc.ClientStream
}

func (x *kaijuDerivativeExchangeRPCStreamPositionsClient) Recv() (*StreamPositionsResponse, error) {
	m := new(StreamPositionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kaijuDerivativeExchangeRPCClient) StreamOrders(ctx context.Context, in *StreamOrdersRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &KaijuDerivativeExchangeRPC_ServiceDesc.Streams[4], "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/StreamOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &kaijuDerivativeExchangeRPCStreamOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KaijuDerivativeExchangeRPC_StreamOrdersClient interface {
	Recv() (*StreamOrdersResponse, error)
	grpc.ClientStream
}

type kaijuDerivativeExchangeRPCStreamOrdersClient struct {
	grpc.ClientStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrdersClient) Recv() (*StreamOrdersResponse, error) {
	m := new(StreamOrdersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kaijuDerivativeExchangeRPCClient) Trades(ctx context.Context, in *TradesRequest, opts ...grpc.CallOption) (*TradesResponse, error) {
	out := new(TradesResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Trades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) StreamTrades(ctx context.Context, in *StreamTradesRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamTradesClient, error) {
	stream, err := c.cc.NewStream(ctx, &KaijuDerivativeExchangeRPC_ServiceDesc.Streams[5], "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/StreamTrades", opts...)
	if err != nil {
		return nil, err
	}
	x := &kaijuDerivativeExchangeRPCStreamTradesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KaijuDerivativeExchangeRPC_StreamTradesClient interface {
	Recv() (*StreamTradesResponse, error)
	grpc.ClientStream
}

type kaijuDerivativeExchangeRPCStreamTradesClient struct {
	grpc.ClientStream
}

func (x *kaijuDerivativeExchangeRPCStreamTradesClient) Recv() (*StreamTradesResponse, error) {
	m := new(StreamTradesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kaijuDerivativeExchangeRPCClient) SubaccountOrdersList(ctx context.Context, in *SubaccountOrdersListRequest, opts ...grpc.CallOption) (*SubaccountOrdersListResponse, error) {
	out := new(SubaccountOrdersListResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/SubaccountOrdersList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) SubaccountTradesList(ctx context.Context, in *SubaccountTradesListRequest, opts ...grpc.CallOption) (*SubaccountTradesListResponse, error) {
	out := new(SubaccountTradesListResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/SubaccountTradesList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) OrdersHistory(ctx context.Context, in *OrdersHistoryRequest, opts ...grpc.CallOption) (*OrdersHistoryResponse, error) {
	out := new(OrdersHistoryResponse)
	err := c.cc.Invoke(ctx, "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/OrdersHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kaijuDerivativeExchangeRPCClient) StreamOrdersHistory(ctx context.Context, in *StreamOrdersHistoryRequest, opts ...grpc.CallOption) (KaijuDerivativeExchangeRPC_StreamOrdersHistoryClient, error) {
	stream, err := c.cc.NewStream(ctx, &KaijuDerivativeExchangeRPC_ServiceDesc.Streams[6], "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/StreamOrdersHistory", opts...)
	if err != nil {
		return nil, err
	}
	x := &kaijuDerivativeExchangeRPCStreamOrdersHistoryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KaijuDerivativeExchangeRPC_StreamOrdersHistoryClient interface {
	Recv() (*StreamOrdersHistoryResponse, error)
	grpc.ClientStream
}

type kaijuDerivativeExchangeRPCStreamOrdersHistoryClient struct {
	grpc.ClientStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrdersHistoryClient) Recv() (*StreamOrdersHistoryResponse, error) {
	m := new(StreamOrdersHistoryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KaijuDerivativeExchangeRPCServer is the server API for KaijuDerivativeExchangeRPC service.
// All implementations must embed UnimplementedKaijuDerivativeExchangeRPCServer
// for forward compatibility
type KaijuDerivativeExchangeRPCServer interface {
	// Markets gets a list of Derivative Markets
	Markets(context.Context, *MarketsRequest) (*MarketsResponse, error)
	// Market gets details of a single derivative market
	Market(context.Context, *MarketRequest) (*MarketResponse, error)
	// StreamMarket streams live updates of selected derivative markets
	StreamMarket(*StreamMarketRequest, KaijuDerivativeExchangeRPC_StreamMarketServer) error
	// BinaryOptionsMarkets gets a list of Binary Options Markets
	BinaryOptionsMarkets(context.Context, *BinaryOptionsMarketsRequest) (*BinaryOptionsMarketsResponse, error)
	// BinaryOptionMarket gets details of a single binary options market
	BinaryOptionsMarket(context.Context, *BinaryOptionsMarketRequest) (*BinaryOptionsMarketResponse, error)
	// Orderbook gets the Orderbook of a Derivative Market
	Orderbook(context.Context, *OrderbookRequest) (*OrderbookResponse, error)
	// Orderbooks gets the Orderbooks of requested derivative markets
	Orderbooks(context.Context, *OrderbooksRequest) (*OrderbooksResponse, error)
	// Stream live snapshot updates of selected derivative market orderbook
	StreamOrderbookSnapshot(*StreamOrderbookSnapshotRequest, KaijuDerivativeExchangeRPC_StreamOrderbookSnapshotServer) error
	// Stream live level updates of selected derivative market orderbook
	StreamOrderbookUpdate(*StreamOrderbookUpdateRequest, KaijuDerivativeExchangeRPC_StreamOrderbookUpdateServer) error
	// DerivativeLimitOrders gets the limit orders of a Derivative Market.
	Orders(context.Context, *OrdersRequest) (*OrdersResponse, error)
	// Positions gets the positions for a trader.
	Positions(context.Context, *PositionsRequest) (*PositionsResponse, error)
	// LiquidablePositions gets all the liquidable positions.
	LiquidablePositions(context.Context, *LiquidablePositionsRequest) (*LiquidablePositionsResponse, error)
	// FundingPayments gets the funding payments for a trader.
	FundingPayments(context.Context, *FundingPaymentsRequest) (*FundingPaymentsResponse, error)
	// FundingRates gets the historical funding rates for a market.
	FundingRates(context.Context, *FundingRatesRequest) (*FundingRatesResponse, error)
	// StreamPositions streams derivatives position updates.
	StreamPositions(*StreamPositionsRequest, KaijuDerivativeExchangeRPC_StreamPositionsServer) error
	// StreamOrders streams updates to individual orders of a Derivative Market.
	StreamOrders(*StreamOrdersRequest, KaijuDerivativeExchangeRPC_StreamOrdersServer) error
	// Trades gets the trades of a Derivative Market.
	Trades(context.Context, *TradesRequest) (*TradesResponse, error)
	// StreamTrades streams newly executed trades from Derivative Market.
	StreamTrades(*StreamTradesRequest, KaijuDerivativeExchangeRPC_StreamTradesServer) error
	// SubaccountOrdersList lists orders posted from this subaccount.
	SubaccountOrdersList(context.Context, *SubaccountOrdersListRequest) (*SubaccountOrdersListResponse, error)
	// SubaccountTradesList gets a list of derivatives trades executed by this
	// subaccount.
	SubaccountTradesList(context.Context, *SubaccountTradesListRequest) (*SubaccountTradesListResponse, error)
	// Lists history orders posted from a subaccount
	OrdersHistory(context.Context, *OrdersHistoryRequest) (*OrdersHistoryResponse, error)
	// Stream updates to historical orders of a derivative Market
	StreamOrdersHistory(*StreamOrdersHistoryRequest, KaijuDerivativeExchangeRPC_StreamOrdersHistoryServer) error
	mustEmbedUnimplementedKaijuDerivativeExchangeRPCServer()
}

// UnimplementedKaijuDerivativeExchangeRPCServer must be embedded to have forward compatible implementations.
type UnimplementedKaijuDerivativeExchangeRPCServer struct {
}

func (UnimplementedKaijuDerivativeExchangeRPCServer) Markets(context.Context, *MarketsRequest) (*MarketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Markets not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) Market(context.Context, *MarketRequest) (*MarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Market not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) StreamMarket(*StreamMarketRequest, KaijuDerivativeExchangeRPC_StreamMarketServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMarket not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) BinaryOptionsMarkets(context.Context, *BinaryOptionsMarketsRequest) (*BinaryOptionsMarketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BinaryOptionsMarkets not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) BinaryOptionsMarket(context.Context, *BinaryOptionsMarketRequest) (*BinaryOptionsMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BinaryOptionsMarket not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) Orderbook(context.Context, *OrderbookRequest) (*OrderbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Orderbook not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) Orderbooks(context.Context, *OrderbooksRequest) (*OrderbooksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Orderbooks not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) StreamOrderbookSnapshot(*StreamOrderbookSnapshotRequest, KaijuDerivativeExchangeRPC_StreamOrderbookSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamOrderbookSnapshot not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) StreamOrderbookUpdate(*StreamOrderbookUpdateRequest, KaijuDerivativeExchangeRPC_StreamOrderbookUpdateServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamOrderbookUpdate not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) Orders(context.Context, *OrdersRequest) (*OrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Orders not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) Positions(context.Context, *PositionsRequest) (*PositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Positions not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) LiquidablePositions(context.Context, *LiquidablePositionsRequest) (*LiquidablePositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidablePositions not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) FundingPayments(context.Context, *FundingPaymentsRequest) (*FundingPaymentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FundingPayments not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) FundingRates(context.Context, *FundingRatesRequest) (*FundingRatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FundingRates not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) StreamPositions(*StreamPositionsRequest, KaijuDerivativeExchangeRPC_StreamPositionsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamPositions not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) StreamOrders(*StreamOrdersRequest, KaijuDerivativeExchangeRPC_StreamOrdersServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamOrders not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) Trades(context.Context, *TradesRequest) (*TradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Trades not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) StreamTrades(*StreamTradesRequest, KaijuDerivativeExchangeRPC_StreamTradesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamTrades not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) SubaccountOrdersList(context.Context, *SubaccountOrdersListRequest) (*SubaccountOrdersListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubaccountOrdersList not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) SubaccountTradesList(context.Context, *SubaccountTradesListRequest) (*SubaccountTradesListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubaccountTradesList not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) OrdersHistory(context.Context, *OrdersHistoryRequest) (*OrdersHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrdersHistory not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) StreamOrdersHistory(*StreamOrdersHistoryRequest, KaijuDerivativeExchangeRPC_StreamOrdersHistoryServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamOrdersHistory not implemented")
}
func (UnimplementedKaijuDerivativeExchangeRPCServer) mustEmbedUnimplementedKaijuDerivativeExchangeRPCServer() {
}

// UnsafeKaijuDerivativeExchangeRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KaijuDerivativeExchangeRPCServer will
// result in compilation errors.
type UnsafeKaijuDerivativeExchangeRPCServer interface {
	mustEmbedUnimplementedKaijuDerivativeExchangeRPCServer()
}

func RegisterKaijuDerivativeExchangeRPCServer(s grpc.ServiceRegistrar, srv KaijuDerivativeExchangeRPCServer) {
	s.RegisterService(&KaijuDerivativeExchangeRPC_ServiceDesc, srv)
}

func _KaijuDerivativeExchangeRPC_Markets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).Markets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Markets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).Markets(ctx, req.(*MarketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_Market_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).Market(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Market",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).Market(ctx, req.(*MarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_StreamMarket_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMarketRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KaijuDerivativeExchangeRPCServer).StreamMarket(m, &kaijuDerivativeExchangeRPCStreamMarketServer{stream})
}

type KaijuDerivativeExchangeRPC_StreamMarketServer interface {
	Send(*StreamMarketResponse) error
	grpc.ServerStream
}

type kaijuDerivativeExchangeRPCStreamMarketServer struct {
	grpc.ServerStream
}

func (x *kaijuDerivativeExchangeRPCStreamMarketServer) Send(m *StreamMarketResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _KaijuDerivativeExchangeRPC_BinaryOptionsMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BinaryOptionsMarketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).BinaryOptionsMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/BinaryOptionsMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).BinaryOptionsMarkets(ctx, req.(*BinaryOptionsMarketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_BinaryOptionsMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BinaryOptionsMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).BinaryOptionsMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/BinaryOptionsMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).BinaryOptionsMarket(ctx, req.(*BinaryOptionsMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_Orderbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).Orderbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Orderbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).Orderbook(ctx, req.(*OrderbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_Orderbooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderbooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).Orderbooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Orderbooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).Orderbooks(ctx, req.(*OrderbooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_StreamOrderbookSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamOrderbookSnapshotRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KaijuDerivativeExchangeRPCServer).StreamOrderbookSnapshot(m, &kaijuDerivativeExchangeRPCStreamOrderbookSnapshotServer{stream})
}

type KaijuDerivativeExchangeRPC_StreamOrderbookSnapshotServer interface {
	Send(*StreamOrderbookSnapshotResponse) error
	grpc.ServerStream
}

type kaijuDerivativeExchangeRPCStreamOrderbookSnapshotServer struct {
	grpc.ServerStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrderbookSnapshotServer) Send(m *StreamOrderbookSnapshotResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _KaijuDerivativeExchangeRPC_StreamOrderbookUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamOrderbookUpdateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KaijuDerivativeExchangeRPCServer).StreamOrderbookUpdate(m, &kaijuDerivativeExchangeRPCStreamOrderbookUpdateServer{stream})
}

type KaijuDerivativeExchangeRPC_StreamOrderbookUpdateServer interface {
	Send(*StreamOrderbookUpdateResponse) error
	grpc.ServerStream
}

type kaijuDerivativeExchangeRPCStreamOrderbookUpdateServer struct {
	grpc.ServerStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrderbookUpdateServer) Send(m *StreamOrderbookUpdateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _KaijuDerivativeExchangeRPC_Orders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).Orders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Orders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).Orders(ctx, req.(*OrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_Positions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).Positions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Positions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).Positions(ctx, req.(*PositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_LiquidablePositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiquidablePositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).LiquidablePositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/LiquidablePositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).LiquidablePositions(ctx, req.(*LiquidablePositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_FundingPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FundingPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).FundingPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/FundingPayments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).FundingPayments(ctx, req.(*FundingPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_FundingRates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FundingRatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).FundingRates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/FundingRates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).FundingRates(ctx, req.(*FundingRatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_StreamPositions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamPositionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KaijuDerivativeExchangeRPCServer).StreamPositions(m, &kaijuDerivativeExchangeRPCStreamPositionsServer{stream})
}

type KaijuDerivativeExchangeRPC_StreamPositionsServer interface {
	Send(*StreamPositionsResponse) error
	grpc.ServerStream
}

type kaijuDerivativeExchangeRPCStreamPositionsServer struct {
	grpc.ServerStream
}

func (x *kaijuDerivativeExchangeRPCStreamPositionsServer) Send(m *StreamPositionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _KaijuDerivativeExchangeRPC_StreamOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KaijuDerivativeExchangeRPCServer).StreamOrders(m, &kaijuDerivativeExchangeRPCStreamOrdersServer{stream})
}

type KaijuDerivativeExchangeRPC_StreamOrdersServer interface {
	Send(*StreamOrdersResponse) error
	grpc.ServerStream
}

type kaijuDerivativeExchangeRPCStreamOrdersServer struct {
	grpc.ServerStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrdersServer) Send(m *StreamOrdersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _KaijuDerivativeExchangeRPC_Trades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).Trades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/Trades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).Trades(ctx, req.(*TradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_StreamTrades_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamTradesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KaijuDerivativeExchangeRPCServer).StreamTrades(m, &kaijuDerivativeExchangeRPCStreamTradesServer{stream})
}

type KaijuDerivativeExchangeRPC_StreamTradesServer interface {
	Send(*StreamTradesResponse) error
	grpc.ServerStream
}

type kaijuDerivativeExchangeRPCStreamTradesServer struct {
	grpc.ServerStream
}

func (x *kaijuDerivativeExchangeRPCStreamTradesServer) Send(m *StreamTradesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _KaijuDerivativeExchangeRPC_SubaccountOrdersList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubaccountOrdersListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).SubaccountOrdersList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/SubaccountOrdersList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).SubaccountOrdersList(ctx, req.(*SubaccountOrdersListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_SubaccountTradesList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubaccountTradesListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).SubaccountTradesList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/SubaccountTradesList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).SubaccountTradesList(ctx, req.(*SubaccountTradesListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_OrdersHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdersHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KaijuDerivativeExchangeRPCServer).OrdersHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC/OrdersHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KaijuDerivativeExchangeRPCServer).OrdersHistory(ctx, req.(*OrdersHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KaijuDerivativeExchangeRPC_StreamOrdersHistory_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamOrdersHistoryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KaijuDerivativeExchangeRPCServer).StreamOrdersHistory(m, &kaijuDerivativeExchangeRPCStreamOrdersHistoryServer{stream})
}

type KaijuDerivativeExchangeRPC_StreamOrdersHistoryServer interface {
	Send(*StreamOrdersHistoryResponse) error
	grpc.ServerStream
}

type kaijuDerivativeExchangeRPCStreamOrdersHistoryServer struct {
	grpc.ServerStream
}

func (x *kaijuDerivativeExchangeRPCStreamOrdersHistoryServer) Send(m *StreamOrdersHistoryResponse) error {
	return x.ServerStream.SendMsg(m)
}

// KaijuDerivativeExchangeRPC_ServiceDesc is the grpc.ServiceDesc for KaijuDerivativeExchangeRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KaijuDerivativeExchangeRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kaiju_derivative_exchange_rpc.KaijuDerivativeExchangeRPC",
	HandlerType: (*KaijuDerivativeExchangeRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Markets",
			Handler:    _KaijuDerivativeExchangeRPC_Markets_Handler,
		},
		{
			MethodName: "Market",
			Handler:    _KaijuDerivativeExchangeRPC_Market_Handler,
		},
		{
			MethodName: "BinaryOptionsMarkets",
			Handler:    _KaijuDerivativeExchangeRPC_BinaryOptionsMarkets_Handler,
		},
		{
			MethodName: "BinaryOptionsMarket",
			Handler:    _KaijuDerivativeExchangeRPC_BinaryOptionsMarket_Handler,
		},
		{
			MethodName: "Orderbook",
			Handler:    _KaijuDerivativeExchangeRPC_Orderbook_Handler,
		},
		{
			MethodName: "Orderbooks",
			Handler:    _KaijuDerivativeExchangeRPC_Orderbooks_Handler,
		},
		{
			MethodName: "Orders",
			Handler:    _KaijuDerivativeExchangeRPC_Orders_Handler,
		},
		{
			MethodName: "Positions",
			Handler:    _KaijuDerivativeExchangeRPC_Positions_Handler,
		},
		{
			MethodName: "LiquidablePositions",
			Handler:    _KaijuDerivativeExchangeRPC_LiquidablePositions_Handler,
		},
		{
			MethodName: "FundingPayments",
			Handler:    _KaijuDerivativeExchangeRPC_FundingPayments_Handler,
		},
		{
			MethodName: "FundingRates",
			Handler:    _KaijuDerivativeExchangeRPC_FundingRates_Handler,
		},
		{
			MethodName: "Trades",
			Handler:    _KaijuDerivativeExchangeRPC_Trades_Handler,
		},
		{
			MethodName: "SubaccountOrdersList",
			Handler:    _KaijuDerivativeExchangeRPC_SubaccountOrdersList_Handler,
		},
		{
			MethodName: "SubaccountTradesList",
			Handler:    _KaijuDerivativeExchangeRPC_SubaccountTradesList_Handler,
		},
		{
			MethodName: "OrdersHistory",
			Handler:    _KaijuDerivativeExchangeRPC_OrdersHistory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMarket",
			Handler:       _KaijuDerivativeExchangeRPC_StreamMarket_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamOrderbookSnapshot",
			Handler:       _KaijuDerivativeExchangeRPC_StreamOrderbookSnapshot_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamOrderbookUpdate",
			Handler:       _KaijuDerivativeExchangeRPC_StreamOrderbookUpdate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPositions",
			Handler:       _KaijuDerivativeExchangeRPC_StreamPositions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamOrders",
			Handler:       _KaijuDerivativeExchangeRPC_StreamOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamTrades",
			Handler:       _KaijuDerivativeExchangeRPC_StreamTrades_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamOrdersHistory",
			Handler:       _KaijuDerivativeExchangeRPC_StreamOrdersHistory_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kaiju_derivative_exchange_rpc.proto",
}
