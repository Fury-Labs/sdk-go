// Code generated by goa v3.3.1, DO NOT EDIT.
//
// InjectiveDerivativeExchangeRPC gRPC client types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-exchange/api/design -o ../

package client

import (
	"unicode/utf8"

	injective_derivative_exchange_rpcpb "github.com/InjectiveLabs/injective-exchange/api/gen/grpc/injective_derivative_exchange_rpc/pb"
	injectivederivativeexchangerpc "github.com/InjectiveLabs/injective-exchange/api/gen/injective_derivative_exchange_rpc"
	goa "goa.design/goa/v3/pkg"
)

// NewMarketsRequest builds the gRPC request type from the payload of the
// "markets" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewMarketsRequest(payload *injectivederivativeexchangerpc.MarketsPayload) *injective_derivative_exchange_rpcpb.MarketsRequest {
	message := &injective_derivative_exchange_rpcpb.MarketsRequest{
		MarketStatus: payload.MarketStatus,
	}
	if payload.QuoteDenom != nil {
		message.QuoteDenom = *payload.QuoteDenom
	}
	return message
}

// NewMarketsResult builds the result type of the "markets" endpoint of the
// "InjectiveDerivativeExchangeRPC" service from the gRPC response type.
func NewMarketsResult(message *injective_derivative_exchange_rpcpb.MarketsResponse) *injectivederivativeexchangerpc.MarketsResult {
	result := &injectivederivativeexchangerpc.MarketsResult{}
	if message.Markets != nil {
		result.Markets = make([]*injectivederivativeexchangerpc.DerivativeMarketInfo, len(message.Markets))
		for i, val := range message.Markets {
			result.Markets[i] = &injectivederivativeexchangerpc.DerivativeMarketInfo{
				MarketID:                 val.MarketId,
				MarketStatus:             val.MarketStatus,
				Ticker:                   val.Ticker,
				OracleBase:               val.OracleBase,
				OracleQuote:              val.OracleQuote,
				OracleType:               val.OracleType,
				InitialMarginRatio:       val.InitialMarginRatio,
				MaintenanceMarginRatio:   val.MaintenanceMarginRatio,
				QuoteDenom:               val.QuoteDenom,
				MakerFeeRate:             val.MakerFeeRate,
				TakerFeeRate:             val.TakerFeeRate,
				ServiceProviderFee:       val.ServiceProviderFee,
				IsPerpetual:              val.IsPerpetual,
				MaxPriceScaleDecimals:    val.MaxPriceScaleDecimals,
				MaxQuantityScaleDecimals: val.MaxQuantityScaleDecimals,
			}
			if val.QuoteTokenMeta != nil {
				result.Markets[i].QuoteTokenMeta = protobufInjectiveDerivativeExchangeRpcpbTokenMetaToInjectivederivativeexchangerpcTokenMeta(val.QuoteTokenMeta)
			}
		}
	}
	return result
}

// NewMarketRequest builds the gRPC request type from the payload of the
// "market" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewMarketRequest(payload *injectivederivativeexchangerpc.MarketPayload) *injective_derivative_exchange_rpcpb.MarketRequest {
	message := &injective_derivative_exchange_rpcpb.MarketRequest{
		MarketId: payload.MarketID,
	}
	return message
}

// NewMarketResult builds the result type of the "market" endpoint of the
// "InjectiveDerivativeExchangeRPC" service from the gRPC response type.
func NewMarketResult(message *injective_derivative_exchange_rpcpb.MarketResponse) *injectivederivativeexchangerpc.MarketResult {
	result := &injectivederivativeexchangerpc.MarketResult{}
	if message.Market != nil {
		result.Market = protobufInjectiveDerivativeExchangeRpcpbDerivativeMarketInfoToInjectivederivativeexchangerpcDerivativeMarketInfo(message.Market)
	}
	return result
}

// NewStreamMarketRequest builds the gRPC request type from the payload of the
// "streamMarket" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewStreamMarketRequest(payload *injectivederivativeexchangerpc.StreamMarketPayload) *injective_derivative_exchange_rpcpb.StreamMarketRequest {
	message := &injective_derivative_exchange_rpcpb.StreamMarketRequest{}
	if payload.MarketIds != nil {
		message.MarketIds = make([]string, len(payload.MarketIds))
		for i, val := range payload.MarketIds {
			message.MarketIds[i] = val
		}
	}
	return message
}

func NewStreamMarketResult(v *injective_derivative_exchange_rpcpb.StreamMarketResponse) *injectivederivativeexchangerpc.StreamMarketResult {
	result := &injectivederivativeexchangerpc.StreamMarketResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Market != nil {
		result.Market = protobufInjectiveDerivativeExchangeRpcpbDerivativeMarketInfoToInjectivederivativeexchangerpcDerivativeMarketInfo(v.Market)
	}
	return result
}

// NewOrderbookRequest builds the gRPC request type from the payload of the
// "orderbook" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewOrderbookRequest(payload *injectivederivativeexchangerpc.OrderbookPayload) *injective_derivative_exchange_rpcpb.OrderbookRequest {
	message := &injective_derivative_exchange_rpcpb.OrderbookRequest{
		MarketId: payload.MarketID,
	}
	return message
}

// NewOrderbookResult builds the result type of the "orderbook" endpoint of the
// "InjectiveDerivativeExchangeRPC" service from the gRPC response type.
func NewOrderbookResult(message *injective_derivative_exchange_rpcpb.OrderbookResponse) *injectivederivativeexchangerpc.OrderbookResult {
	result := &injectivederivativeexchangerpc.OrderbookResult{}
	if message.Orderbook != nil {
		result.Orderbook = protobufInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderbookToInjectivederivativeexchangerpcDerivativeLimitOrderbook(message.Orderbook)
	}
	return result
}

// NewStreamOrderbookRequest builds the gRPC request type from the payload of
// the "streamOrderbook" endpoint of the "InjectiveDerivativeExchangeRPC"
// service.
func NewStreamOrderbookRequest(payload *injectivederivativeexchangerpc.StreamOrderbookPayload) *injective_derivative_exchange_rpcpb.StreamOrderbookRequest {
	message := &injective_derivative_exchange_rpcpb.StreamOrderbookRequest{
		MarketId: payload.MarketID,
	}
	return message
}

func NewStreamOrderbookResult(v *injective_derivative_exchange_rpcpb.StreamOrderbookResponse) *injectivederivativeexchangerpc.StreamOrderbookResult {
	result := &injectivederivativeexchangerpc.StreamOrderbookResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Orderbook != nil {
		result.Orderbook = protobufInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderbookToInjectivederivativeexchangerpcDerivativeLimitOrderbook(v.Orderbook)
	}
	return result
}

// NewOrdersRequest builds the gRPC request type from the payload of the
// "orders" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewOrdersRequest(payload *injectivederivativeexchangerpc.DerivativeLimitOrdersFilter) *injective_derivative_exchange_rpcpb.OrdersRequest {
	message := &injective_derivative_exchange_rpcpb.OrdersRequest{
		MarketId: payload.MarketID,
	}
	if payload.OrderType != nil {
		message.OrderType = *payload.OrderType
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

// NewOrdersResult builds the result type of the "orders" endpoint of the
// "InjectiveDerivativeExchangeRPC" service from the gRPC response type.
func NewOrdersResult(message *injective_derivative_exchange_rpcpb.OrdersResponse) *injectivederivativeexchangerpc.OrdersResult {
	result := &injectivederivativeexchangerpc.OrdersResult{}
	if message.Orders != nil {
		result.Orders = make([]*injectivederivativeexchangerpc.DerivativeLimitOrder, len(message.Orders))
		for i, val := range message.Orders {
			result.Orders[i] = &injectivederivativeexchangerpc.DerivativeLimitOrder{
				OrderHash:        val.OrderHash,
				OrderType:        val.OrderType,
				MarketID:         val.MarketId,
				SubaccountID:     val.SubaccountId,
				IsReduceOnly:     val.IsReduceOnly,
				Margin:           val.Margin,
				Price:            val.Price,
				Quantity:         val.Quantity,
				UnfilledQuantity: val.UnfilledQuantity,
				FeeRecipient:     val.FeeRecipient,
				State:            val.State,
				CreatedAt:        val.CreatedAt,
			}
			if val.TriggerPrice != "" {
				result.Orders[i].TriggerPrice = &val.TriggerPrice
			}
			if val.UpdatedAt != 0 {
				result.Orders[i].UpdatedAt = &val.UpdatedAt
			}
		}
	}
	return result
}

// NewPositionsRequest builds the gRPC request type from the payload of the
// "positions" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewPositionsRequest(payload *injectivederivativeexchangerpc.DerivativePositionsFilter) *injective_derivative_exchange_rpcpb.PositionsRequest {
	message := &injective_derivative_exchange_rpcpb.PositionsRequest{}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	if payload.MarketID != nil {
		message.MarketId = *payload.MarketID
	}
	return message
}

// NewPositionsResult builds the result type of the "positions" endpoint of the
// "InjectiveDerivativeExchangeRPC" service from the gRPC response type.
func NewPositionsResult(message *injective_derivative_exchange_rpcpb.PositionsResponse) *injectivederivativeexchangerpc.PositionsResult {
	result := &injectivederivativeexchangerpc.PositionsResult{}
	if message.Positions != nil {
		result.Positions = make([]*injectivederivativeexchangerpc.DerivativePosition, len(message.Positions))
		for i, val := range message.Positions {
			result.Positions[i] = &injectivederivativeexchangerpc.DerivativePosition{
				MarketID:         val.MarketId,
				SubaccountID:     val.SubaccountId,
				Direction:        val.Direction,
				Quantity:         val.Quantity,
				EntryPrice:       val.EntryPrice,
				Margin:           val.Margin,
				HoldQuantity:     val.HoldQuantity,
				LiquidationPrice: val.LiquidationPrice,
				MarkPrice:        val.MarkPrice,
				ImpliedPNL:       val.ImpliedPnl,
				Leverage:         val.Leverage,
			}
		}
	}
	return result
}

// NewStreamOrdersRequest builds the gRPC request type from the payload of the
// "streamOrders" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewStreamOrdersRequest(payload *injectivederivativeexchangerpc.DerivativeLimitOrdersFilter) *injective_derivative_exchange_rpcpb.StreamOrdersRequest {
	message := &injective_derivative_exchange_rpcpb.StreamOrdersRequest{
		MarketId: payload.MarketID,
	}
	if payload.OrderType != nil {
		message.OrderType = *payload.OrderType
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

func NewStreamOrdersResult(v *injective_derivative_exchange_rpcpb.StreamOrdersResponse) *injectivederivativeexchangerpc.StreamOrdersResult {
	result := &injectivederivativeexchangerpc.StreamOrdersResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Order != nil {
		result.Order = protobufInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderToInjectivederivativeexchangerpcDerivativeLimitOrder(v.Order)
	}
	return result
}

// NewTradesRequest builds the gRPC request type from the payload of the
// "trades" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewTradesRequest(payload *injectivederivativeexchangerpc.DerivativeTradesFilter) *injective_derivative_exchange_rpcpb.TradesRequest {
	message := &injective_derivative_exchange_rpcpb.TradesRequest{
		MarketId: payload.MarketID,
	}
	if payload.ExecutionType != nil {
		message.ExecutionType = *payload.ExecutionType
	}
	if payload.ExecutionSide != nil {
		message.ExecutionSide = *payload.ExecutionSide
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

// NewTradesResult builds the result type of the "trades" endpoint of the
// "InjectiveDerivativeExchangeRPC" service from the gRPC response type.
func NewTradesResult(message *injective_derivative_exchange_rpcpb.TradesResponse) *injectivederivativeexchangerpc.TradesResult {
	result := &injectivederivativeexchangerpc.TradesResult{}
	if message.Trades != nil {
		result.Trades = make([]*injectivederivativeexchangerpc.DerivativeTrade, len(message.Trades))
		for i, val := range message.Trades {
			result.Trades[i] = &injectivederivativeexchangerpc.DerivativeTrade{
				OrderHash:          val.OrderHash,
				SubaccountID:       val.SubaccountId,
				MarketID:           val.MarketId,
				TradeExecutionType: val.TradeExecutionType,
				IsLiquidation:      val.IsLiquidation,
				Payout:             val.Payout,
				Fee:                val.Fee,
				ExecutedAt:         val.ExecutedAt,
			}
			if val.PositionDelta != nil {
				result.Trades[i].PositionDelta = protobufInjectiveDerivativeExchangeRpcpbPositionDeltaToInjectivederivativeexchangerpcPositionDelta(val.PositionDelta)
			}
		}
	}
	return result
}

// NewStreamTradesRequest builds the gRPC request type from the payload of the
// "streamTrades" endpoint of the "InjectiveDerivativeExchangeRPC" service.
func NewStreamTradesRequest(payload *injectivederivativeexchangerpc.DerivativeTradesFilter) *injective_derivative_exchange_rpcpb.StreamTradesRequest {
	message := &injective_derivative_exchange_rpcpb.StreamTradesRequest{
		MarketId: payload.MarketID,
	}
	if payload.ExecutionType != nil {
		message.ExecutionType = *payload.ExecutionType
	}
	if payload.ExecutionSide != nil {
		message.ExecutionSide = *payload.ExecutionSide
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

func NewStreamTradesResult(v *injective_derivative_exchange_rpcpb.StreamTradesResponse) *injectivederivativeexchangerpc.StreamTradesResult {
	result := &injectivederivativeexchangerpc.StreamTradesResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Trade != nil {
		result.Trade = protobufInjectiveDerivativeExchangeRpcpbDerivativeTradeToInjectivederivativeexchangerpcDerivativeTrade(v.Trade)
	}
	return result
}

// NewSubaccountOrdersListRequest builds the gRPC request type from the payload
// of the "subaccountOrdersList" endpoint of the
// "InjectiveDerivativeExchangeRPC" service.
func NewSubaccountOrdersListRequest(payload *injectivederivativeexchangerpc.SubaccountOrdersListPayload) *injective_derivative_exchange_rpcpb.SubaccountOrdersListRequest {
	message := &injective_derivative_exchange_rpcpb.SubaccountOrdersListRequest{
		SubaccountId: payload.SubaccountID,
	}
	if payload.MarketID != nil {
		message.MarketId = *payload.MarketID
	}
	return message
}

// NewSubaccountOrdersListResult builds the result type of the
// "subaccountOrdersList" endpoint of the "InjectiveDerivativeExchangeRPC"
// service from the gRPC response type.
func NewSubaccountOrdersListResult(message *injective_derivative_exchange_rpcpb.SubaccountOrdersListResponse) *injectivederivativeexchangerpc.SubaccountOrdersListResult {
	result := &injectivederivativeexchangerpc.SubaccountOrdersListResult{}
	if message.Orders != nil {
		result.Orders = make([]*injectivederivativeexchangerpc.DerivativeLimitOrder, len(message.Orders))
		for i, val := range message.Orders {
			result.Orders[i] = &injectivederivativeexchangerpc.DerivativeLimitOrder{
				OrderHash:        val.OrderHash,
				OrderType:        val.OrderType,
				MarketID:         val.MarketId,
				SubaccountID:     val.SubaccountId,
				IsReduceOnly:     val.IsReduceOnly,
				Margin:           val.Margin,
				Price:            val.Price,
				Quantity:         val.Quantity,
				UnfilledQuantity: val.UnfilledQuantity,
				FeeRecipient:     val.FeeRecipient,
				State:            val.State,
				CreatedAt:        val.CreatedAt,
			}
			if val.TriggerPrice != "" {
				result.Orders[i].TriggerPrice = &val.TriggerPrice
			}
			if val.UpdatedAt != 0 {
				result.Orders[i].UpdatedAt = &val.UpdatedAt
			}
		}
	}
	return result
}

// NewSubaccountTradesListRequest builds the gRPC request type from the payload
// of the "subaccountTradesList" endpoint of the
// "InjectiveDerivativeExchangeRPC" service.
func NewSubaccountTradesListRequest(payload *injectivederivativeexchangerpc.SubaccountTradesListPayload) *injective_derivative_exchange_rpcpb.SubaccountTradesListRequest {
	message := &injective_derivative_exchange_rpcpb.SubaccountTradesListRequest{
		SubaccountId: payload.SubaccountID,
	}
	if payload.MarketID != nil {
		message.MarketId = *payload.MarketID
	}
	if payload.ExecutionType != nil {
		message.ExecutionType = *payload.ExecutionType
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	return message
}

// NewSubaccountTradesListResult builds the result type of the
// "subaccountTradesList" endpoint of the "InjectiveDerivativeExchangeRPC"
// service from the gRPC response type.
func NewSubaccountTradesListResult(message *injective_derivative_exchange_rpcpb.SubaccountTradesListResponse) *injectivederivativeexchangerpc.SubaccountTradesListResult {
	result := &injectivederivativeexchangerpc.SubaccountTradesListResult{}
	if message.Trades != nil {
		result.Trades = make([]*injectivederivativeexchangerpc.DerivativeTrade, len(message.Trades))
		for i, val := range message.Trades {
			result.Trades[i] = &injectivederivativeexchangerpc.DerivativeTrade{
				OrderHash:          val.OrderHash,
				SubaccountID:       val.SubaccountId,
				MarketID:           val.MarketId,
				TradeExecutionType: val.TradeExecutionType,
				IsLiquidation:      val.IsLiquidation,
				Payout:             val.Payout,
				Fee:                val.Fee,
				ExecutedAt:         val.ExecutedAt,
			}
			if val.PositionDelta != nil {
				result.Trades[i].PositionDelta = protobufInjectiveDerivativeExchangeRpcpbPositionDeltaToInjectivederivativeexchangerpcPositionDelta(val.PositionDelta)
			}
		}
	}
	return result
}

// ValidateMarketsResponse runs the validations defined on MarketsResponse.
func ValidateMarketsResponse(message *injective_derivative_exchange_rpcpb.MarketsResponse) (err error) {
	for _, e := range message.Markets {
		if e != nil {
			if err2 := ValidateDerivativeMarketInfo(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDerivativeMarketInfo runs the validations defined on
// DerivativeMarketInfo.
func ValidateDerivativeMarketInfo(message *injective_derivative_exchange_rpcpb.DerivativeMarketInfo) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.marketId", message.MarketId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.MarketId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, true))
	}
	if utf8.RuneCountInString(message.MarketId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, false))
	}
	if !(message.MarketStatus == "active" || message.MarketStatus == "paused" || message.MarketStatus == "suspended" || message.MarketStatus == "demolished" || message.MarketStatus == "expired") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.marketStatus", message.MarketStatus, []interface{}{"active", "paused", "suspended", "demolished", "expired"}))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.initialMarginRatio", message.InitialMarginRatio, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.InitialMarginRatio) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.initialMarginRatio", message.InitialMarginRatio, utf8.RuneCountInString(message.InitialMarginRatio), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.maintenanceMarginRatio", message.MaintenanceMarginRatio, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.MaintenanceMarginRatio) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.maintenanceMarginRatio", message.MaintenanceMarginRatio, utf8.RuneCountInString(message.MaintenanceMarginRatio), 100, false))
	}
	if message.QuoteTokenMeta != nil {
		if err2 := ValidateTokenMeta(message.QuoteTokenMeta); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.makerFeeRate", message.MakerFeeRate, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.MakerFeeRate) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.makerFeeRate", message.MakerFeeRate, utf8.RuneCountInString(message.MakerFeeRate), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.takerFeeRate", message.TakerFeeRate, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.TakerFeeRate) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.takerFeeRate", message.TakerFeeRate, utf8.RuneCountInString(message.TakerFeeRate), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.serviceProviderFee", message.ServiceProviderFee, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.ServiceProviderFee) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.serviceProviderFee", message.ServiceProviderFee, utf8.RuneCountInString(message.ServiceProviderFee), 100, false))
	}
	return
}

// ValidateTokenMeta runs the validations defined on TokenMeta.
func ValidateTokenMeta(message *injective_derivative_exchange_rpcpb.TokenMeta) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.address", message.Address, "^0x[0-9a-fA-F]{40}$"))
	if utf8.RuneCountInString(message.Address) < 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.address", message.Address, utf8.RuneCountInString(message.Address), 42, true))
	}
	if utf8.RuneCountInString(message.Address) > 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.address", message.Address, utf8.RuneCountInString(message.Address), 42, false))
	}
	if utf8.RuneCountInString(message.Symbol) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.symbol", message.Symbol, utf8.RuneCountInString(message.Symbol), 16, false))
	}
	if message.Logo != "" {
		if utf8.RuneCountInString(message.Logo) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("message.logo", message.Logo, utf8.RuneCountInString(message.Logo), 256, false))
		}
	}
	if message.Decimals < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("message.decimals", message.Decimals, 0, true))
	}
	if message.Decimals > 18 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("message.decimals", message.Decimals, 18, false))
	}
	return
}

// ValidateMarketResponse runs the validations defined on MarketResponse.
func ValidateMarketResponse(message *injective_derivative_exchange_rpcpb.MarketResponse) (err error) {
	if message.Market != nil {
		if err2 := ValidateDerivativeMarketInfo(message.Market); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateStreamMarketResponse runs the validations defined on
// StreamMarketResponse.
func ValidateStreamMarketResponse(message *injective_derivative_exchange_rpcpb.StreamMarketResponse) (err error) {
	if message.Market == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("market", "message"))
	}
	if message.Market != nil {
		if err2 := ValidateDerivativeMarketInfo(message.Market); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "delete" || message.OperationType == "replace" || message.OperationType == "update" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "delete", "replace", "update", "invalidate"}))
	}
	return
}

// ValidateOrderbookResponse runs the validations defined on OrderbookResponse.
func ValidateOrderbookResponse(message *injective_derivative_exchange_rpcpb.OrderbookResponse) (err error) {
	if message.Orderbook != nil {
		if err2 := ValidateDerivativeLimitOrderbook(message.Orderbook); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDerivativeLimitOrderbook runs the validations defined on
// DerivativeLimitOrderbook.
func ValidateDerivativeLimitOrderbook(message *injective_derivative_exchange_rpcpb.DerivativeLimitOrderbook) (err error) {
	for _, e := range message.Buys {
		if e != nil {
			if err2 := ValidatePriceLevel(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range message.Sells {
		if e != nil {
			if err2 := ValidatePriceLevel(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidatePriceLevel runs the validations defined on PriceLevel.
func ValidatePriceLevel(message *injective_derivative_exchange_rpcpb.PriceLevel) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.price", message.Price, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Price) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.price", message.Price, utf8.RuneCountInString(message.Price), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.quantity", message.Quantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Quantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.quantity", message.Quantity, utf8.RuneCountInString(message.Quantity), 100, false))
	}
	return
}

// ValidateStreamOrderbookResponse runs the validations defined on
// StreamOrderbookResponse.
func ValidateStreamOrderbookResponse(message *injective_derivative_exchange_rpcpb.StreamOrderbookResponse) (err error) {
	if message.Orderbook == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orderbook", "message"))
	}
	if message.Orderbook != nil {
		if err2 := ValidateDerivativeLimitOrderbook(message.Orderbook); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "delete" || message.OperationType == "replace" || message.OperationType == "update" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "delete", "replace", "update", "invalidate"}))
	}
	return
}

// ValidateOrdersResponse runs the validations defined on OrdersResponse.
func ValidateOrdersResponse(message *injective_derivative_exchange_rpcpb.OrdersResponse) (err error) {
	for _, e := range message.Orders {
		if e != nil {
			if err2 := ValidateDerivativeLimitOrder(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDerivativeLimitOrder runs the validations defined on
// DerivativeLimitOrder.
func ValidateDerivativeLimitOrder(message *injective_derivative_exchange_rpcpb.DerivativeLimitOrder) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.orderHash", message.OrderHash, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.OrderHash) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, true))
	}
	if utf8.RuneCountInString(message.OrderHash) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, false))
	}
	if !(message.OrderType == "buy" || message.OrderType == "sell" || message.OrderType == "stop_buy" || message.OrderType == "stop_sell" || message.OrderType == "take_buy" || message.OrderType == "take_sell") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.orderType", message.OrderType, []interface{}{"buy", "sell", "stop_buy", "stop_sell", "take_buy", "take_sell"}))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.marketId", message.MarketId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.MarketId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, true))
	}
	if utf8.RuneCountInString(message.MarketId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.subaccountId", message.SubaccountId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.SubaccountId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, true))
	}
	if utf8.RuneCountInString(message.SubaccountId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.margin", message.Margin, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Margin) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.margin", message.Margin, utf8.RuneCountInString(message.Margin), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.price", message.Price, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Price) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.price", message.Price, utf8.RuneCountInString(message.Price), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.quantity", message.Quantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Quantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.quantity", message.Quantity, utf8.RuneCountInString(message.Quantity), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.unfilledQuantity", message.UnfilledQuantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.UnfilledQuantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.unfilledQuantity", message.UnfilledQuantity, utf8.RuneCountInString(message.UnfilledQuantity), 100, false))
	}
	if message.TriggerPrice != "" {
		err = goa.MergeErrors(err, goa.ValidatePattern("message.triggerPrice", message.TriggerPrice, "^\\d+(\\.\\d+)?$"))
	}
	if message.TriggerPrice != "" {
		if utf8.RuneCountInString(message.TriggerPrice) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("message.triggerPrice", message.TriggerPrice, utf8.RuneCountInString(message.TriggerPrice), 100, false))
		}
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.feeRecipient", message.FeeRecipient, "^inj1[0-9a-zA-Z]{38}$"))
	if utf8.RuneCountInString(message.FeeRecipient) < 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.feeRecipient", message.FeeRecipient, utf8.RuneCountInString(message.FeeRecipient), 42, true))
	}
	if utf8.RuneCountInString(message.FeeRecipient) > 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.feeRecipient", message.FeeRecipient, utf8.RuneCountInString(message.FeeRecipient), 42, false))
	}
	if !(message.State == "unfilled" || message.State == "filled" || message.State == "canceled") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.state", message.State, []interface{}{"unfilled", "filled", "canceled"}))
	}
	return
}

// ValidatePositionsResponse runs the validations defined on PositionsResponse.
func ValidatePositionsResponse(message *injective_derivative_exchange_rpcpb.PositionsResponse) (err error) {
	for _, e := range message.Positions {
		if e != nil {
			if err2 := ValidateDerivativePosition(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDerivativePosition runs the validations defined on
// DerivativePosition.
func ValidateDerivativePosition(message *injective_derivative_exchange_rpcpb.DerivativePosition) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.marketId", message.MarketId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.MarketId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, true))
	}
	if utf8.RuneCountInString(message.MarketId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.subaccountId", message.SubaccountId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.SubaccountId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, true))
	}
	if utf8.RuneCountInString(message.SubaccountId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, false))
	}
	if !(message.Direction == "long" || message.Direction == "short") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.direction", message.Direction, []interface{}{"long", "short"}))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.quantity", message.Quantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Quantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.quantity", message.Quantity, utf8.RuneCountInString(message.Quantity), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.entryPrice", message.EntryPrice, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.EntryPrice) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.entryPrice", message.EntryPrice, utf8.RuneCountInString(message.EntryPrice), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.margin", message.Margin, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Margin) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.margin", message.Margin, utf8.RuneCountInString(message.Margin), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.holdQuantity", message.HoldQuantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.HoldQuantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.holdQuantity", message.HoldQuantity, utf8.RuneCountInString(message.HoldQuantity), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.liquidationPrice", message.LiquidationPrice, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.LiquidationPrice) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.liquidationPrice", message.LiquidationPrice, utf8.RuneCountInString(message.LiquidationPrice), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.markPrice", message.MarkPrice, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.MarkPrice) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.markPrice", message.MarkPrice, utf8.RuneCountInString(message.MarkPrice), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.impliedPNL", message.ImpliedPnl, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.ImpliedPnl) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.impliedPNL", message.ImpliedPnl, utf8.RuneCountInString(message.ImpliedPnl), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.leverage", message.Leverage, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Leverage) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.leverage", message.Leverage, utf8.RuneCountInString(message.Leverage), 100, false))
	}
	return
}

// ValidateStreamOrdersResponse runs the validations defined on
// StreamOrdersResponse.
func ValidateStreamOrdersResponse(message *injective_derivative_exchange_rpcpb.StreamOrdersResponse) (err error) {
	if message.Order == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("order", "message"))
	}
	if message.Order != nil {
		if err2 := ValidateDerivativeLimitOrder(message.Order); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "delete" || message.OperationType == "replace" || message.OperationType == "update" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "delete", "replace", "update", "invalidate"}))
	}
	return
}

// ValidateTradesResponse runs the validations defined on TradesResponse.
func ValidateTradesResponse(message *injective_derivative_exchange_rpcpb.TradesResponse) (err error) {
	for _, e := range message.Trades {
		if e != nil {
			if err2 := ValidateDerivativeTrade(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDerivativeTrade runs the validations defined on DerivativeTrade.
func ValidateDerivativeTrade(message *injective_derivative_exchange_rpcpb.DerivativeTrade) (err error) {
	if message.PositionDelta == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("positionDelta", "message"))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.orderHash", message.OrderHash, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.OrderHash) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, true))
	}
	if utf8.RuneCountInString(message.OrderHash) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.subaccountId", message.SubaccountId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.SubaccountId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, true))
	}
	if utf8.RuneCountInString(message.SubaccountId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.marketId", message.MarketId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.MarketId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, true))
	}
	if utf8.RuneCountInString(message.MarketId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, false))
	}
	if !(message.TradeExecutionType == "market" || message.TradeExecutionType == "limitFill" || message.TradeExecutionType == "limitMatchRestingOrder" || message.TradeExecutionType == "limitMatchNewOrder") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.tradeExecutionType", message.TradeExecutionType, []interface{}{"market", "limitFill", "limitMatchRestingOrder", "limitMatchNewOrder"}))
	}
	if message.PositionDelta != nil {
		if err2 := ValidatePositionDelta(message.PositionDelta); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.payout", message.Payout, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Payout) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.payout", message.Payout, utf8.RuneCountInString(message.Payout), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.fee", message.Fee, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Fee) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.fee", message.Fee, utf8.RuneCountInString(message.Fee), 100, false))
	}
	return
}

// ValidatePositionDelta runs the validations defined on PositionDelta.
func ValidatePositionDelta(message *injective_derivative_exchange_rpcpb.PositionDelta) (err error) {
	if !(message.TradeDirection == "buy" || message.TradeDirection == "sell") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.tradeDirection", message.TradeDirection, []interface{}{"buy", "sell"}))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.executionPrice", message.ExecutionPrice, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.ExecutionPrice) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.executionPrice", message.ExecutionPrice, utf8.RuneCountInString(message.ExecutionPrice), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.executionQuantity", message.ExecutionQuantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.ExecutionQuantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.executionQuantity", message.ExecutionQuantity, utf8.RuneCountInString(message.ExecutionQuantity), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.executionMargin", message.ExecutionMargin, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.ExecutionMargin) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.executionMargin", message.ExecutionMargin, utf8.RuneCountInString(message.ExecutionMargin), 100, false))
	}
	return
}

// ValidateStreamTradesResponse runs the validations defined on
// StreamTradesResponse.
func ValidateStreamTradesResponse(message *injective_derivative_exchange_rpcpb.StreamTradesResponse) (err error) {
	if message.Trade == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("trade", "message"))
	}
	if message.Trade != nil {
		if err2 := ValidateDerivativeTrade(message.Trade); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "invalidate"}))
	}
	return
}

// ValidateSubaccountOrdersListResponse runs the validations defined on
// SubaccountOrdersListResponse.
func ValidateSubaccountOrdersListResponse(message *injective_derivative_exchange_rpcpb.SubaccountOrdersListResponse) (err error) {
	for _, e := range message.Orders {
		if e != nil {
			if err2 := ValidateDerivativeLimitOrder(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateSubaccountTradesListResponse runs the validations defined on
// SubaccountTradesListResponse.
func ValidateSubaccountTradesListResponse(message *injective_derivative_exchange_rpcpb.SubaccountTradesListResponse) (err error) {
	for _, e := range message.Trades {
		if e != nil {
			if err2 := ValidateDerivativeTrade(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// svcInjectivederivativeexchangerpcTokenMetaToInjectiveDerivativeExchangeRpcpbTokenMeta
// builds a value of type *injective_derivative_exchange_rpcpb.TokenMeta from a
// value of type *injectivederivativeexchangerpc.TokenMeta.
func svcInjectivederivativeexchangerpcTokenMetaToInjectiveDerivativeExchangeRpcpbTokenMeta(v *injectivederivativeexchangerpc.TokenMeta) *injective_derivative_exchange_rpcpb.TokenMeta {
	if v == nil {
		return nil
	}
	res := &injective_derivative_exchange_rpcpb.TokenMeta{
		Name:      v.Name,
		Address:   v.Address,
		Symbol:    v.Symbol,
		Decimals:  int32(v.Decimals),
		UpdatedAt: v.UpdatedAt,
	}
	if v.Logo != nil {
		res.Logo = *v.Logo
	}

	return res
}

// protobufInjectiveDerivativeExchangeRpcpbTokenMetaToInjectivederivativeexchangerpcTokenMeta
// builds a value of type *injectivederivativeexchangerpc.TokenMeta from a
// value of type *injective_derivative_exchange_rpcpb.TokenMeta.
func protobufInjectiveDerivativeExchangeRpcpbTokenMetaToInjectivederivativeexchangerpcTokenMeta(v *injective_derivative_exchange_rpcpb.TokenMeta) *injectivederivativeexchangerpc.TokenMeta {
	if v == nil {
		return nil
	}
	res := &injectivederivativeexchangerpc.TokenMeta{
		Name:      v.Name,
		Address:   v.Address,
		Symbol:    v.Symbol,
		Decimals:  int(v.Decimals),
		UpdatedAt: v.UpdatedAt,
	}
	if v.Logo != "" {
		res.Logo = &v.Logo
	}

	return res
}

// svcInjectivederivativeexchangerpcDerivativeMarketInfoToInjectiveDerivativeExchangeRpcpbDerivativeMarketInfo
// builds a value of type
// *injective_derivative_exchange_rpcpb.DerivativeMarketInfo from a value of
// type *injectivederivativeexchangerpc.DerivativeMarketInfo.
func svcInjectivederivativeexchangerpcDerivativeMarketInfoToInjectiveDerivativeExchangeRpcpbDerivativeMarketInfo(v *injectivederivativeexchangerpc.DerivativeMarketInfo) *injective_derivative_exchange_rpcpb.DerivativeMarketInfo {
	if v == nil {
		return nil
	}
	res := &injective_derivative_exchange_rpcpb.DerivativeMarketInfo{
		MarketId:                 v.MarketID,
		MarketStatus:             v.MarketStatus,
		Ticker:                   v.Ticker,
		OracleBase:               v.OracleBase,
		OracleQuote:              v.OracleQuote,
		OracleType:               v.OracleType,
		InitialMarginRatio:       v.InitialMarginRatio,
		MaintenanceMarginRatio:   v.MaintenanceMarginRatio,
		QuoteDenom:               v.QuoteDenom,
		MakerFeeRate:             v.MakerFeeRate,
		TakerFeeRate:             v.TakerFeeRate,
		ServiceProviderFee:       v.ServiceProviderFee,
		IsPerpetual:              v.IsPerpetual,
		MaxPriceScaleDecimals:    v.MaxPriceScaleDecimals,
		MaxQuantityScaleDecimals: v.MaxQuantityScaleDecimals,
	}
	if v.QuoteTokenMeta != nil {
		res.QuoteTokenMeta = svcInjectivederivativeexchangerpcTokenMetaToInjectiveDerivativeExchangeRpcpbTokenMeta(v.QuoteTokenMeta)
	}

	return res
}

// protobufInjectiveDerivativeExchangeRpcpbDerivativeMarketInfoToInjectivederivativeexchangerpcDerivativeMarketInfo
// builds a value of type *injectivederivativeexchangerpc.DerivativeMarketInfo
// from a value of type
// *injective_derivative_exchange_rpcpb.DerivativeMarketInfo.
func protobufInjectiveDerivativeExchangeRpcpbDerivativeMarketInfoToInjectivederivativeexchangerpcDerivativeMarketInfo(v *injective_derivative_exchange_rpcpb.DerivativeMarketInfo) *injectivederivativeexchangerpc.DerivativeMarketInfo {
	if v == nil {
		return nil
	}
	res := &injectivederivativeexchangerpc.DerivativeMarketInfo{
		MarketID:                 v.MarketId,
		MarketStatus:             v.MarketStatus,
		Ticker:                   v.Ticker,
		OracleBase:               v.OracleBase,
		OracleQuote:              v.OracleQuote,
		OracleType:               v.OracleType,
		InitialMarginRatio:       v.InitialMarginRatio,
		MaintenanceMarginRatio:   v.MaintenanceMarginRatio,
		QuoteDenom:               v.QuoteDenom,
		MakerFeeRate:             v.MakerFeeRate,
		TakerFeeRate:             v.TakerFeeRate,
		ServiceProviderFee:       v.ServiceProviderFee,
		IsPerpetual:              v.IsPerpetual,
		MaxPriceScaleDecimals:    v.MaxPriceScaleDecimals,
		MaxQuantityScaleDecimals: v.MaxQuantityScaleDecimals,
	}
	if v.QuoteTokenMeta != nil {
		res.QuoteTokenMeta = protobufInjectiveDerivativeExchangeRpcpbTokenMetaToInjectivederivativeexchangerpcTokenMeta(v.QuoteTokenMeta)
	}

	return res
}

// svcInjectivederivativeexchangerpcDerivativeLimitOrderbookToInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderbook
// builds a value of type
// *injective_derivative_exchange_rpcpb.DerivativeLimitOrderbook from a value
// of type *injectivederivativeexchangerpc.DerivativeLimitOrderbook.
func svcInjectivederivativeexchangerpcDerivativeLimitOrderbookToInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderbook(v *injectivederivativeexchangerpc.DerivativeLimitOrderbook) *injective_derivative_exchange_rpcpb.DerivativeLimitOrderbook {
	if v == nil {
		return nil
	}
	res := &injective_derivative_exchange_rpcpb.DerivativeLimitOrderbook{}
	if v.Buys != nil {
		res.Buys = make([]*injective_derivative_exchange_rpcpb.PriceLevel, len(v.Buys))
		for i, val := range v.Buys {
			res.Buys[i] = &injective_derivative_exchange_rpcpb.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}
	if v.Sells != nil {
		res.Sells = make([]*injective_derivative_exchange_rpcpb.PriceLevel, len(v.Sells))
		for i, val := range v.Sells {
			res.Sells[i] = &injective_derivative_exchange_rpcpb.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}

	return res
}

// protobufInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderbookToInjectivederivativeexchangerpcDerivativeLimitOrderbook
// builds a value of type
// *injectivederivativeexchangerpc.DerivativeLimitOrderbook from a value of
// type *injective_derivative_exchange_rpcpb.DerivativeLimitOrderbook.
func protobufInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderbookToInjectivederivativeexchangerpcDerivativeLimitOrderbook(v *injective_derivative_exchange_rpcpb.DerivativeLimitOrderbook) *injectivederivativeexchangerpc.DerivativeLimitOrderbook {
	if v == nil {
		return nil
	}
	res := &injectivederivativeexchangerpc.DerivativeLimitOrderbook{}
	if v.Buys != nil {
		res.Buys = make([]*injectivederivativeexchangerpc.PriceLevel, len(v.Buys))
		for i, val := range v.Buys {
			res.Buys[i] = &injectivederivativeexchangerpc.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}
	if v.Sells != nil {
		res.Sells = make([]*injectivederivativeexchangerpc.PriceLevel, len(v.Sells))
		for i, val := range v.Sells {
			res.Sells[i] = &injectivederivativeexchangerpc.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}

	return res
}

// svcInjectivederivativeexchangerpcDerivativeLimitOrderToInjectiveDerivativeExchangeRpcpbDerivativeLimitOrder
// builds a value of type
// *injective_derivative_exchange_rpcpb.DerivativeLimitOrder from a value of
// type *injectivederivativeexchangerpc.DerivativeLimitOrder.
func svcInjectivederivativeexchangerpcDerivativeLimitOrderToInjectiveDerivativeExchangeRpcpbDerivativeLimitOrder(v *injectivederivativeexchangerpc.DerivativeLimitOrder) *injective_derivative_exchange_rpcpb.DerivativeLimitOrder {
	res := &injective_derivative_exchange_rpcpb.DerivativeLimitOrder{
		OrderHash:        v.OrderHash,
		OrderType:        v.OrderType,
		MarketId:         v.MarketID,
		SubaccountId:     v.SubaccountID,
		IsReduceOnly:     v.IsReduceOnly,
		Margin:           v.Margin,
		Price:            v.Price,
		Quantity:         v.Quantity,
		UnfilledQuantity: v.UnfilledQuantity,
		FeeRecipient:     v.FeeRecipient,
		State:            v.State,
		CreatedAt:        v.CreatedAt,
	}
	if v.TriggerPrice != nil {
		res.TriggerPrice = *v.TriggerPrice
	}
	if v.UpdatedAt != nil {
		res.UpdatedAt = *v.UpdatedAt
	}

	return res
}

// protobufInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderToInjectivederivativeexchangerpcDerivativeLimitOrder
// builds a value of type *injectivederivativeexchangerpc.DerivativeLimitOrder
// from a value of type
// *injective_derivative_exchange_rpcpb.DerivativeLimitOrder.
func protobufInjectiveDerivativeExchangeRpcpbDerivativeLimitOrderToInjectivederivativeexchangerpcDerivativeLimitOrder(v *injective_derivative_exchange_rpcpb.DerivativeLimitOrder) *injectivederivativeexchangerpc.DerivativeLimitOrder {
	res := &injectivederivativeexchangerpc.DerivativeLimitOrder{
		OrderHash:        v.OrderHash,
		OrderType:        v.OrderType,
		MarketID:         v.MarketId,
		SubaccountID:     v.SubaccountId,
		IsReduceOnly:     v.IsReduceOnly,
		Margin:           v.Margin,
		Price:            v.Price,
		Quantity:         v.Quantity,
		UnfilledQuantity: v.UnfilledQuantity,
		FeeRecipient:     v.FeeRecipient,
		State:            v.State,
		CreatedAt:        v.CreatedAt,
	}
	if v.TriggerPrice != "" {
		res.TriggerPrice = &v.TriggerPrice
	}
	if v.UpdatedAt != 0 {
		res.UpdatedAt = &v.UpdatedAt
	}

	return res
}

// svcInjectivederivativeexchangerpcPositionDeltaToInjectiveDerivativeExchangeRpcpbPositionDelta
// builds a value of type *injective_derivative_exchange_rpcpb.PositionDelta
// from a value of type *injectivederivativeexchangerpc.PositionDelta.
func svcInjectivederivativeexchangerpcPositionDeltaToInjectiveDerivativeExchangeRpcpbPositionDelta(v *injectivederivativeexchangerpc.PositionDelta) *injective_derivative_exchange_rpcpb.PositionDelta {
	res := &injective_derivative_exchange_rpcpb.PositionDelta{
		TradeDirection:    v.TradeDirection,
		ExecutionPrice:    v.ExecutionPrice,
		ExecutionQuantity: v.ExecutionQuantity,
		ExecutionMargin:   v.ExecutionMargin,
	}

	return res
}

// protobufInjectiveDerivativeExchangeRpcpbPositionDeltaToInjectivederivativeexchangerpcPositionDelta
// builds a value of type *injectivederivativeexchangerpc.PositionDelta from a
// value of type *injective_derivative_exchange_rpcpb.PositionDelta.
func protobufInjectiveDerivativeExchangeRpcpbPositionDeltaToInjectivederivativeexchangerpcPositionDelta(v *injective_derivative_exchange_rpcpb.PositionDelta) *injectivederivativeexchangerpc.PositionDelta {
	res := &injectivederivativeexchangerpc.PositionDelta{
		TradeDirection:    v.TradeDirection,
		ExecutionPrice:    v.ExecutionPrice,
		ExecutionQuantity: v.ExecutionQuantity,
		ExecutionMargin:   v.ExecutionMargin,
	}

	return res
}

// svcInjectivederivativeexchangerpcDerivativeTradeToInjectiveDerivativeExchangeRpcpbDerivativeTrade
// builds a value of type *injective_derivative_exchange_rpcpb.DerivativeTrade
// from a value of type *injectivederivativeexchangerpc.DerivativeTrade.
func svcInjectivederivativeexchangerpcDerivativeTradeToInjectiveDerivativeExchangeRpcpbDerivativeTrade(v *injectivederivativeexchangerpc.DerivativeTrade) *injective_derivative_exchange_rpcpb.DerivativeTrade {
	res := &injective_derivative_exchange_rpcpb.DerivativeTrade{
		OrderHash:          v.OrderHash,
		SubaccountId:       v.SubaccountID,
		MarketId:           v.MarketID,
		TradeExecutionType: v.TradeExecutionType,
		IsLiquidation:      v.IsLiquidation,
		Payout:             v.Payout,
		Fee:                v.Fee,
		ExecutedAt:         v.ExecutedAt,
	}
	if v.PositionDelta != nil {
		res.PositionDelta = svcInjectivederivativeexchangerpcPositionDeltaToInjectiveDerivativeExchangeRpcpbPositionDelta(v.PositionDelta)
	}

	return res
}

// protobufInjectiveDerivativeExchangeRpcpbDerivativeTradeToInjectivederivativeexchangerpcDerivativeTrade
// builds a value of type *injectivederivativeexchangerpc.DerivativeTrade from
// a value of type *injective_derivative_exchange_rpcpb.DerivativeTrade.
func protobufInjectiveDerivativeExchangeRpcpbDerivativeTradeToInjectivederivativeexchangerpcDerivativeTrade(v *injective_derivative_exchange_rpcpb.DerivativeTrade) *injectivederivativeexchangerpc.DerivativeTrade {
	res := &injectivederivativeexchangerpc.DerivativeTrade{
		OrderHash:          v.OrderHash,
		SubaccountID:       v.SubaccountId,
		MarketID:           v.MarketId,
		TradeExecutionType: v.TradeExecutionType,
		IsLiquidation:      v.IsLiquidation,
		Payout:             v.Payout,
		Fee:                v.Fee,
		ExecutedAt:         v.ExecutedAt,
	}
	if v.PositionDelta != nil {
		res.PositionDelta = protobufInjectiveDerivativeExchangeRpcpbPositionDeltaToInjectivederivativeexchangerpcPositionDelta(v.PositionDelta)
	}

	return res
}
