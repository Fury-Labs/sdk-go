// Code generated by goa v3.3.1, DO NOT EDIT.
//
// InjectiveDerivativeExchangeRPC gRPC client encoders and decoders
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-exchange/api/design -o ../

package client

import (
	"context"

	injective_derivative_exchange_rpcpb "github.com/InjectiveLabs/injective-exchange/api/gen/grpc/injective_derivative_exchange_rpc/pb"
	injectivederivativeexchangerpc "github.com/InjectiveLabs/injective-exchange/api/gen/injective_derivative_exchange_rpc"
	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildMarketsFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "markets" endpoint.
func BuildMarketsFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Markets(ctx, reqpb.(*injective_derivative_exchange_rpcpb.MarketsRequest), opts...)
		}
		return grpccli.Markets(ctx, &injective_derivative_exchange_rpcpb.MarketsRequest{}, opts...)
	}
}

// EncodeMarketsRequest encodes requests sent to InjectiveDerivativeExchangeRPC
// markets endpoint.
func EncodeMarketsRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.MarketsPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "markets", "*injectivederivativeexchangerpc.MarketsPayload", v)
	}
	return NewMarketsRequest(payload), nil
}

// DecodeMarketsResponse decodes responses from the
// InjectiveDerivativeExchangeRPC markets endpoint.
func DecodeMarketsResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.MarketsResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "markets", "*injective_derivative_exchange_rpcpb.MarketsResponse", v)
	}
	if err := ValidateMarketsResponse(message); err != nil {
		return nil, err
	}
	res := NewMarketsResult(message)
	return res, nil
}

// BuildMarketFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "market" endpoint.
func BuildMarketFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Market(ctx, reqpb.(*injective_derivative_exchange_rpcpb.MarketRequest), opts...)
		}
		return grpccli.Market(ctx, &injective_derivative_exchange_rpcpb.MarketRequest{}, opts...)
	}
}

// EncodeMarketRequest encodes requests sent to InjectiveDerivativeExchangeRPC
// market endpoint.
func EncodeMarketRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.MarketPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "market", "*injectivederivativeexchangerpc.MarketPayload", v)
	}
	return NewMarketRequest(payload), nil
}

// DecodeMarketResponse decodes responses from the
// InjectiveDerivativeExchangeRPC market endpoint.
func DecodeMarketResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.MarketResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "market", "*injective_derivative_exchange_rpcpb.MarketResponse", v)
	}
	if err := ValidateMarketResponse(message); err != nil {
		return nil, err
	}
	res := NewMarketResult(message)
	return res, nil
}

// BuildStreamMarketFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "streamMarket" endpoint.
func BuildStreamMarketFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamMarket(ctx, reqpb.(*injective_derivative_exchange_rpcpb.StreamMarketRequest), opts...)
		}
		return grpccli.StreamMarket(ctx, &injective_derivative_exchange_rpcpb.StreamMarketRequest{}, opts...)
	}
}

// EncodeStreamMarketRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC streamMarket endpoint.
func EncodeStreamMarketRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.StreamMarketPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "streamMarket", "*injectivederivativeexchangerpc.StreamMarketPayload", v)
	}
	return NewStreamMarketRequest(payload), nil
}

// DecodeStreamMarketResponse decodes responses from the
// InjectiveDerivativeExchangeRPC streamMarket endpoint.
func DecodeStreamMarketResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamMarketClientStream{
		stream: v.(injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPC_StreamMarketClient),
	}, nil
}

// BuildOrderbookFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "orderbook" endpoint.
func BuildOrderbookFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Orderbook(ctx, reqpb.(*injective_derivative_exchange_rpcpb.OrderbookRequest), opts...)
		}
		return grpccli.Orderbook(ctx, &injective_derivative_exchange_rpcpb.OrderbookRequest{}, opts...)
	}
}

// EncodeOrderbookRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC orderbook endpoint.
func EncodeOrderbookRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.OrderbookPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "orderbook", "*injectivederivativeexchangerpc.OrderbookPayload", v)
	}
	return NewOrderbookRequest(payload), nil
}

// DecodeOrderbookResponse decodes responses from the
// InjectiveDerivativeExchangeRPC orderbook endpoint.
func DecodeOrderbookResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.OrderbookResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "orderbook", "*injective_derivative_exchange_rpcpb.OrderbookResponse", v)
	}
	if err := ValidateOrderbookResponse(message); err != nil {
		return nil, err
	}
	res := NewOrderbookResult(message)
	return res, nil
}

// BuildStreamOrderbookFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "streamOrderbook" endpoint.
func BuildStreamOrderbookFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamOrderbook(ctx, reqpb.(*injective_derivative_exchange_rpcpb.StreamOrderbookRequest), opts...)
		}
		return grpccli.StreamOrderbook(ctx, &injective_derivative_exchange_rpcpb.StreamOrderbookRequest{}, opts...)
	}
}

// EncodeStreamOrderbookRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC streamOrderbook endpoint.
func EncodeStreamOrderbookRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.StreamOrderbookPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "streamOrderbook", "*injectivederivativeexchangerpc.StreamOrderbookPayload", v)
	}
	return NewStreamOrderbookRequest(payload), nil
}

// DecodeStreamOrderbookResponse decodes responses from the
// InjectiveDerivativeExchangeRPC streamOrderbook endpoint.
func DecodeStreamOrderbookResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamOrderbookClientStream{
		stream: v.(injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPC_StreamOrderbookClient),
	}, nil
}

// BuildOrdersFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "orders" endpoint.
func BuildOrdersFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Orders(ctx, reqpb.(*injective_derivative_exchange_rpcpb.OrdersRequest), opts...)
		}
		return grpccli.Orders(ctx, &injective_derivative_exchange_rpcpb.OrdersRequest{}, opts...)
	}
}

// EncodeOrdersRequest encodes requests sent to InjectiveDerivativeExchangeRPC
// orders endpoint.
func EncodeOrdersRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.DerivativeLimitOrdersFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "orders", "*injectivederivativeexchangerpc.DerivativeLimitOrdersFilter", v)
	}
	return NewOrdersRequest(payload), nil
}

// DecodeOrdersResponse decodes responses from the
// InjectiveDerivativeExchangeRPC orders endpoint.
func DecodeOrdersResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.OrdersResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "orders", "*injective_derivative_exchange_rpcpb.OrdersResponse", v)
	}
	if err := ValidateOrdersResponse(message); err != nil {
		return nil, err
	}
	res := NewOrdersResult(message)
	return res, nil
}

// BuildPositionsFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "positions" endpoint.
func BuildPositionsFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Positions(ctx, reqpb.(*injective_derivative_exchange_rpcpb.PositionsRequest), opts...)
		}
		return grpccli.Positions(ctx, &injective_derivative_exchange_rpcpb.PositionsRequest{}, opts...)
	}
}

// EncodePositionsRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC positions endpoint.
func EncodePositionsRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.DerivativePositionsFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "positions", "*injectivederivativeexchangerpc.DerivativePositionsFilter", v)
	}
	return NewPositionsRequest(payload), nil
}

// DecodePositionsResponse decodes responses from the
// InjectiveDerivativeExchangeRPC positions endpoint.
func DecodePositionsResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.PositionsResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "positions", "*injective_derivative_exchange_rpcpb.PositionsResponse", v)
	}
	if err := ValidatePositionsResponse(message); err != nil {
		return nil, err
	}
	res := NewPositionsResult(message)
	return res, nil
}

// BuildStreamOrdersFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "streamOrders" endpoint.
func BuildStreamOrdersFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamOrders(ctx, reqpb.(*injective_derivative_exchange_rpcpb.StreamOrdersRequest), opts...)
		}
		return grpccli.StreamOrders(ctx, &injective_derivative_exchange_rpcpb.StreamOrdersRequest{}, opts...)
	}
}

// EncodeStreamOrdersRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC streamOrders endpoint.
func EncodeStreamOrdersRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.DerivativeLimitOrdersFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "streamOrders", "*injectivederivativeexchangerpc.DerivativeLimitOrdersFilter", v)
	}
	return NewStreamOrdersRequest(payload), nil
}

// DecodeStreamOrdersResponse decodes responses from the
// InjectiveDerivativeExchangeRPC streamOrders endpoint.
func DecodeStreamOrdersResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamOrdersClientStream{
		stream: v.(injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPC_StreamOrdersClient),
	}, nil
}

// BuildTradesFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "trades" endpoint.
func BuildTradesFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Trades(ctx, reqpb.(*injective_derivative_exchange_rpcpb.TradesRequest), opts...)
		}
		return grpccli.Trades(ctx, &injective_derivative_exchange_rpcpb.TradesRequest{}, opts...)
	}
}

// EncodeTradesRequest encodes requests sent to InjectiveDerivativeExchangeRPC
// trades endpoint.
func EncodeTradesRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.DerivativeTradesFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "trades", "*injectivederivativeexchangerpc.DerivativeTradesFilter", v)
	}
	return NewTradesRequest(payload), nil
}

// DecodeTradesResponse decodes responses from the
// InjectiveDerivativeExchangeRPC trades endpoint.
func DecodeTradesResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.TradesResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "trades", "*injective_derivative_exchange_rpcpb.TradesResponse", v)
	}
	if err := ValidateTradesResponse(message); err != nil {
		return nil, err
	}
	res := NewTradesResult(message)
	return res, nil
}

// BuildStreamTradesFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "streamTrades" endpoint.
func BuildStreamTradesFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamTrades(ctx, reqpb.(*injective_derivative_exchange_rpcpb.StreamTradesRequest), opts...)
		}
		return grpccli.StreamTrades(ctx, &injective_derivative_exchange_rpcpb.StreamTradesRequest{}, opts...)
	}
}

// EncodeStreamTradesRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC streamTrades endpoint.
func EncodeStreamTradesRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.DerivativeTradesFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "streamTrades", "*injectivederivativeexchangerpc.DerivativeTradesFilter", v)
	}
	return NewStreamTradesRequest(payload), nil
}

// DecodeStreamTradesResponse decodes responses from the
// InjectiveDerivativeExchangeRPC streamTrades endpoint.
func DecodeStreamTradesResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamTradesClientStream{
		stream: v.(injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPC_StreamTradesClient),
	}, nil
}

// BuildSubaccountOrdersListFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "subaccountOrdersList" endpoint.
func BuildSubaccountOrdersListFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountOrdersList(ctx, reqpb.(*injective_derivative_exchange_rpcpb.SubaccountOrdersListRequest), opts...)
		}
		return grpccli.SubaccountOrdersList(ctx, &injective_derivative_exchange_rpcpb.SubaccountOrdersListRequest{}, opts...)
	}
}

// EncodeSubaccountOrdersListRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC subaccountOrdersList endpoint.
func EncodeSubaccountOrdersListRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.SubaccountOrdersListPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "subaccountOrdersList", "*injectivederivativeexchangerpc.SubaccountOrdersListPayload", v)
	}
	return NewSubaccountOrdersListRequest(payload), nil
}

// DecodeSubaccountOrdersListResponse decodes responses from the
// InjectiveDerivativeExchangeRPC subaccountOrdersList endpoint.
func DecodeSubaccountOrdersListResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.SubaccountOrdersListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "subaccountOrdersList", "*injective_derivative_exchange_rpcpb.SubaccountOrdersListResponse", v)
	}
	if err := ValidateSubaccountOrdersListResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountOrdersListResult(message)
	return res, nil
}

// BuildSubaccountTradesListFunc builds the remote method to invoke for
// "InjectiveDerivativeExchangeRPC" service "subaccountTradesList" endpoint.
func BuildSubaccountTradesListFunc(grpccli injective_derivative_exchange_rpcpb.InjectiveDerivativeExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountTradesList(ctx, reqpb.(*injective_derivative_exchange_rpcpb.SubaccountTradesListRequest), opts...)
		}
		return grpccli.SubaccountTradesList(ctx, &injective_derivative_exchange_rpcpb.SubaccountTradesListRequest{}, opts...)
	}
}

// EncodeSubaccountTradesListRequest encodes requests sent to
// InjectiveDerivativeExchangeRPC subaccountTradesList endpoint.
func EncodeSubaccountTradesListRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivederivativeexchangerpc.SubaccountTradesListPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "subaccountTradesList", "*injectivederivativeexchangerpc.SubaccountTradesListPayload", v)
	}
	return NewSubaccountTradesListRequest(payload), nil
}

// DecodeSubaccountTradesListResponse decodes responses from the
// InjectiveDerivativeExchangeRPC subaccountTradesList endpoint.
func DecodeSubaccountTradesListResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_derivative_exchange_rpcpb.SubaccountTradesListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveDerivativeExchangeRPC", "subaccountTradesList", "*injective_derivative_exchange_rpcpb.SubaccountTradesListResponse", v)
	}
	if err := ValidateSubaccountTradesListResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountTradesListResult(message)
	return res, nil
}
