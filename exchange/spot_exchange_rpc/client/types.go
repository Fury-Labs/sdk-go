// Code generated by goa v3.3.1, DO NOT EDIT.
//
// InjectiveSpotExchangeRPC gRPC client types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-exchange/api/design -o ../

package client

import (
	"unicode/utf8"

	injective_spot_exchange_rpcpb "github.com/InjectiveLabs/injective-exchange/api/gen/grpc/injective_spot_exchange_rpc/pb"
	injectivespotexchangerpc "github.com/InjectiveLabs/injective-exchange/api/gen/injective_spot_exchange_rpc"
	goa "goa.design/goa/v3/pkg"
)

// NewMarketsRequest builds the gRPC request type from the payload of the
// "markets" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewMarketsRequest(payload *injectivespotexchangerpc.MarketsPayload) *injective_spot_exchange_rpcpb.MarketsRequest {
	message := &injective_spot_exchange_rpcpb.MarketsRequest{
		MarketStatus: payload.MarketStatus,
	}
	if payload.BaseDenom != nil {
		message.BaseDenom = *payload.BaseDenom
	}
	if payload.QuoteDenom != nil {
		message.QuoteDenom = *payload.QuoteDenom
	}
	return message
}

// NewMarketsResult builds the result type of the "markets" endpoint of the
// "InjectiveSpotExchangeRPC" service from the gRPC response type.
func NewMarketsResult(message *injective_spot_exchange_rpcpb.MarketsResponse) *injectivespotexchangerpc.MarketsResult {
	result := &injectivespotexchangerpc.MarketsResult{}
	if message.Markets != nil {
		result.Markets = make([]*injectivespotexchangerpc.SpotMarketInfo, len(message.Markets))
		for i, val := range message.Markets {
			result.Markets[i] = &injectivespotexchangerpc.SpotMarketInfo{
				MarketID:                 val.MarketId,
				MarketStatus:             val.MarketStatus,
				Ticker:                   val.Ticker,
				BaseDenom:                val.BaseDenom,
				QuoteDenom:               val.QuoteDenom,
				MakerFeeRate:             val.MakerFeeRate,
				TakerFeeRate:             val.TakerFeeRate,
				ServiceProviderFee:       val.ServiceProviderFee,
				MaxPriceScaleDecimals:    val.MaxPriceScaleDecimals,
				MaxQuantityScaleDecimals: val.MaxQuantityScaleDecimals,
			}
			if val.BaseTokenMeta != nil {
				result.Markets[i].BaseTokenMeta = protobufInjectiveSpotExchangeRpcpbTokenMetaToInjectivespotexchangerpcTokenMeta(val.BaseTokenMeta)
			}
			if val.QuoteTokenMeta != nil {
				result.Markets[i].QuoteTokenMeta = protobufInjectiveSpotExchangeRpcpbTokenMetaToInjectivespotexchangerpcTokenMeta(val.QuoteTokenMeta)
			}
			if val.MaxPriceScaleDecimals == 0 {
				result.Markets[i].MaxPriceScaleDecimals = 6
			}
			if val.MaxQuantityScaleDecimals == 0 {
				result.Markets[i].MaxQuantityScaleDecimals = 6
			}
		}
	}
	return result
}

// NewMarketRequest builds the gRPC request type from the payload of the
// "market" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewMarketRequest(payload *injectivespotexchangerpc.MarketPayload) *injective_spot_exchange_rpcpb.MarketRequest {
	message := &injective_spot_exchange_rpcpb.MarketRequest{
		MarketId: payload.MarketID,
	}
	return message
}

// NewMarketResult builds the result type of the "market" endpoint of the
// "InjectiveSpotExchangeRPC" service from the gRPC response type.
func NewMarketResult(message *injective_spot_exchange_rpcpb.MarketResponse) *injectivespotexchangerpc.MarketResult {
	result := &injectivespotexchangerpc.MarketResult{}
	if message.Market != nil {
		result.Market = protobufInjectiveSpotExchangeRpcpbSpotMarketInfoToInjectivespotexchangerpcSpotMarketInfo(message.Market)
	}
	return result
}

// NewStreamMarketsRequest builds the gRPC request type from the payload of the
// "streamMarkets" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewStreamMarketsRequest(payload *injectivespotexchangerpc.StreamMarketsPayload) *injective_spot_exchange_rpcpb.StreamMarketsRequest {
	message := &injective_spot_exchange_rpcpb.StreamMarketsRequest{}
	if payload.MarketIds != nil {
		message.MarketIds = make([]string, len(payload.MarketIds))
		for i, val := range payload.MarketIds {
			message.MarketIds[i] = val
		}
	}
	return message
}

func NewStreamMarketsResult(v *injective_spot_exchange_rpcpb.StreamMarketsResponse) *injectivespotexchangerpc.StreamMarketsResult {
	result := &injectivespotexchangerpc.StreamMarketsResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Market != nil {
		result.Market = protobufInjectiveSpotExchangeRpcpbSpotMarketInfoToInjectivespotexchangerpcSpotMarketInfo(v.Market)
	}
	return result
}

// NewOrderbookRequest builds the gRPC request type from the payload of the
// "orderbook" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewOrderbookRequest(payload *injectivespotexchangerpc.OrderbookPayload) *injective_spot_exchange_rpcpb.OrderbookRequest {
	message := &injective_spot_exchange_rpcpb.OrderbookRequest{
		MarketId: payload.MarketID,
	}
	return message
}

// NewOrderbookResult builds the result type of the "orderbook" endpoint of the
// "InjectiveSpotExchangeRPC" service from the gRPC response type.
func NewOrderbookResult(message *injective_spot_exchange_rpcpb.OrderbookResponse) *injectivespotexchangerpc.OrderbookResult {
	result := &injectivespotexchangerpc.OrderbookResult{}
	if message.Orderbook != nil {
		result.Orderbook = protobufInjectiveSpotExchangeRpcpbSpotLimitOrderbookToInjectivespotexchangerpcSpotLimitOrderbook(message.Orderbook)
	}
	return result
}

// NewStreamOrderbookRequest builds the gRPC request type from the payload of
// the "streamOrderbook" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewStreamOrderbookRequest(payload *injectivespotexchangerpc.StreamOrderbookPayload) *injective_spot_exchange_rpcpb.StreamOrderbookRequest {
	message := &injective_spot_exchange_rpcpb.StreamOrderbookRequest{
		MarketId: payload.MarketID,
	}
	return message
}

func NewStreamOrderbookResult(v *injective_spot_exchange_rpcpb.StreamOrderbookResponse) *injectivespotexchangerpc.StreamOrderbookResult {
	result := &injectivespotexchangerpc.StreamOrderbookResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Orderbook != nil {
		result.Orderbook = protobufInjectiveSpotExchangeRpcpbSpotLimitOrderbookToInjectivespotexchangerpcSpotLimitOrderbook(v.Orderbook)
	}
	return result
}

// NewOrdersRequest builds the gRPC request type from the payload of the
// "orders" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewOrdersRequest(payload *injectivespotexchangerpc.SpotLimitOrdersFilter) *injective_spot_exchange_rpcpb.OrdersRequest {
	message := &injective_spot_exchange_rpcpb.OrdersRequest{
		MarketId: payload.MarketID,
	}
	if payload.OrderType != nil {
		message.OrderType = *payload.OrderType
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

// NewOrdersResult builds the result type of the "orders" endpoint of the
// "InjectiveSpotExchangeRPC" service from the gRPC response type.
func NewOrdersResult(message *injective_spot_exchange_rpcpb.OrdersResponse) *injectivespotexchangerpc.OrdersResult {
	result := &injectivespotexchangerpc.OrdersResult{}
	if message.Orders != nil {
		result.Orders = make([]*injectivespotexchangerpc.SpotLimitOrder, len(message.Orders))
		for i, val := range message.Orders {
			result.Orders[i] = &injectivespotexchangerpc.SpotLimitOrder{
				OrderHash:        val.OrderHash,
				OrderType:        val.OrderType,
				MarketID:         val.MarketId,
				SubaccountID:     val.SubaccountId,
				Price:            val.Price,
				Quantity:         val.Quantity,
				UnfilledQuantity: val.UnfilledQuantity,
				TriggerPrice:     val.TriggerPrice,
				FeeRecipient:     val.FeeRecipient,
				State:            val.State,
				CreatedAt:        val.CreatedAt,
			}
			if val.UpdatedAt != 0 {
				result.Orders[i].UpdatedAt = &val.UpdatedAt
			}
		}
	}
	return result
}

// NewStreamOrdersRequest builds the gRPC request type from the payload of the
// "streamOrders" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewStreamOrdersRequest(payload *injectivespotexchangerpc.SpotLimitOrdersFilter) *injective_spot_exchange_rpcpb.StreamOrdersRequest {
	message := &injective_spot_exchange_rpcpb.StreamOrdersRequest{
		MarketId: payload.MarketID,
	}
	if payload.OrderType != nil {
		message.OrderType = *payload.OrderType
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

func NewStreamOrdersResult(v *injective_spot_exchange_rpcpb.StreamOrdersResponse) *injectivespotexchangerpc.StreamOrdersResult {
	result := &injectivespotexchangerpc.StreamOrdersResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Order != nil {
		result.Order = protobufInjectiveSpotExchangeRpcpbSpotLimitOrderToInjectivespotexchangerpcSpotLimitOrder(v.Order)
	}
	return result
}

// NewTradesRequest builds the gRPC request type from the payload of the
// "trades" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewTradesRequest(payload *injectivespotexchangerpc.SpotTradesFilter) *injective_spot_exchange_rpcpb.TradesRequest {
	message := &injective_spot_exchange_rpcpb.TradesRequest{
		MarketId: payload.MarketID,
	}
	if payload.ExecutionType != nil {
		message.ExecutionType = *payload.ExecutionType
	}
	if payload.ExecutionSide != nil {
		message.ExecutionSide = *payload.ExecutionSide
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

// NewTradesResult builds the result type of the "trades" endpoint of the
// "InjectiveSpotExchangeRPC" service from the gRPC response type.
func NewTradesResult(message *injective_spot_exchange_rpcpb.TradesResponse) *injectivespotexchangerpc.TradesResult {
	result := &injectivespotexchangerpc.TradesResult{}
	if message.Trades != nil {
		result.Trades = make([]*injectivespotexchangerpc.SpotTrade, len(message.Trades))
		for i, val := range message.Trades {
			result.Trades[i] = &injectivespotexchangerpc.SpotTrade{
				OrderHash:          val.OrderHash,
				SubaccountID:       val.SubaccountId,
				MarketID:           val.MarketId,
				TradeExecutionType: val.TradeExecutionType,
				TradeDirection:     val.TradeDirection,
				Fee:                val.Fee,
				ExecutedAt:         val.ExecutedAt,
			}
			if val.Price != nil {
				result.Trades[i].Price = protobufInjectiveSpotExchangeRpcpbPriceLevelToInjectivespotexchangerpcPriceLevel(val.Price)
			}
		}
	}
	return result
}

// NewStreamTradesRequest builds the gRPC request type from the payload of the
// "streamTrades" endpoint of the "InjectiveSpotExchangeRPC" service.
func NewStreamTradesRequest(payload *injectivespotexchangerpc.SpotTradesFilter) *injective_spot_exchange_rpcpb.StreamTradesRequest {
	message := &injective_spot_exchange_rpcpb.StreamTradesRequest{
		MarketId: payload.MarketID,
	}
	if payload.ExecutionType != nil {
		message.ExecutionType = *payload.ExecutionType
	}
	if payload.ExecutionSide != nil {
		message.ExecutionSide = *payload.ExecutionSide
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	if payload.SubaccountID != nil {
		message.SubaccountId = *payload.SubaccountID
	}
	return message
}

func NewStreamTradesResult(v *injective_spot_exchange_rpcpb.StreamTradesResponse) *injectivespotexchangerpc.StreamTradesResult {
	result := &injectivespotexchangerpc.StreamTradesResult{
		OperationType: v.OperationType,
		Timestamp:     v.Timestamp,
	}
	if v.Trade != nil {
		result.Trade = protobufInjectiveSpotExchangeRpcpbSpotTradeToInjectivespotexchangerpcSpotTrade(v.Trade)
	}
	return result
}

// NewSubaccountOrdersListRequest builds the gRPC request type from the payload
// of the "subaccountOrdersList" endpoint of the "InjectiveSpotExchangeRPC"
// service.
func NewSubaccountOrdersListRequest(payload *injectivespotexchangerpc.SubaccountOrdersListPayload) *injective_spot_exchange_rpcpb.SubaccountOrdersListRequest {
	message := &injective_spot_exchange_rpcpb.SubaccountOrdersListRequest{
		SubaccountId: payload.SubaccountID,
	}
	if payload.MarketID != nil {
		message.MarketId = *payload.MarketID
	}
	return message
}

// NewSubaccountOrdersListResult builds the result type of the
// "subaccountOrdersList" endpoint of the "InjectiveSpotExchangeRPC" service
// from the gRPC response type.
func NewSubaccountOrdersListResult(message *injective_spot_exchange_rpcpb.SubaccountOrdersListResponse) *injectivespotexchangerpc.SubaccountOrdersListResult {
	result := &injectivespotexchangerpc.SubaccountOrdersListResult{}
	if message.Orders != nil {
		result.Orders = make([]*injectivespotexchangerpc.SpotLimitOrder, len(message.Orders))
		for i, val := range message.Orders {
			result.Orders[i] = &injectivespotexchangerpc.SpotLimitOrder{
				OrderHash:        val.OrderHash,
				OrderType:        val.OrderType,
				MarketID:         val.MarketId,
				SubaccountID:     val.SubaccountId,
				Price:            val.Price,
				Quantity:         val.Quantity,
				UnfilledQuantity: val.UnfilledQuantity,
				TriggerPrice:     val.TriggerPrice,
				FeeRecipient:     val.FeeRecipient,
				State:            val.State,
				CreatedAt:        val.CreatedAt,
			}
			if val.UpdatedAt != 0 {
				result.Orders[i].UpdatedAt = &val.UpdatedAt
			}
		}
	}
	return result
}

// NewSubaccountTradesListRequest builds the gRPC request type from the payload
// of the "subaccountTradesList" endpoint of the "InjectiveSpotExchangeRPC"
// service.
func NewSubaccountTradesListRequest(payload *injectivespotexchangerpc.SubaccountTradesListPayload) *injective_spot_exchange_rpcpb.SubaccountTradesListRequest {
	message := &injective_spot_exchange_rpcpb.SubaccountTradesListRequest{
		SubaccountId: payload.SubaccountID,
	}
	if payload.MarketID != nil {
		message.MarketId = *payload.MarketID
	}
	if payload.ExecutionType != nil {
		message.ExecutionType = *payload.ExecutionType
	}
	if payload.Direction != nil {
		message.Direction = *payload.Direction
	}
	return message
}

// NewSubaccountTradesListResult builds the result type of the
// "subaccountTradesList" endpoint of the "InjectiveSpotExchangeRPC" service
// from the gRPC response type.
func NewSubaccountTradesListResult(message *injective_spot_exchange_rpcpb.SubaccountTradesListResponse) *injectivespotexchangerpc.SubaccountTradesListResult {
	result := &injectivespotexchangerpc.SubaccountTradesListResult{}
	if message.Trades != nil {
		result.Trades = make([]*injectivespotexchangerpc.SpotTrade, len(message.Trades))
		for i, val := range message.Trades {
			result.Trades[i] = &injectivespotexchangerpc.SpotTrade{
				OrderHash:          val.OrderHash,
				SubaccountID:       val.SubaccountId,
				MarketID:           val.MarketId,
				TradeExecutionType: val.TradeExecutionType,
				TradeDirection:     val.TradeDirection,
				Fee:                val.Fee,
				ExecutedAt:         val.ExecutedAt,
			}
			if val.Price != nil {
				result.Trades[i].Price = protobufInjectiveSpotExchangeRpcpbPriceLevelToInjectivespotexchangerpcPriceLevel(val.Price)
			}
		}
	}
	return result
}

// ValidateMarketsResponse runs the validations defined on MarketsResponse.
func ValidateMarketsResponse(message *injective_spot_exchange_rpcpb.MarketsResponse) (err error) {
	for _, e := range message.Markets {
		if e != nil {
			if err2 := ValidateSpotMarketInfo(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateSpotMarketInfo runs the validations defined on SpotMarketInfo.
func ValidateSpotMarketInfo(message *injective_spot_exchange_rpcpb.SpotMarketInfo) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.marketId", message.MarketId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.MarketId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, true))
	}
	if utf8.RuneCountInString(message.MarketId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, false))
	}
	if !(message.MarketStatus == "active" || message.MarketStatus == "paused" || message.MarketStatus == "suspended" || message.MarketStatus == "demolished" || message.MarketStatus == "expired") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.marketStatus", message.MarketStatus, []interface{}{"active", "paused", "suspended", "demolished", "expired"}))
	}
	if message.BaseTokenMeta != nil {
		if err2 := ValidateTokenMeta(message.BaseTokenMeta); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if message.QuoteTokenMeta != nil {
		if err2 := ValidateTokenMeta(message.QuoteTokenMeta); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.makerFeeRate", message.MakerFeeRate, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.MakerFeeRate) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.makerFeeRate", message.MakerFeeRate, utf8.RuneCountInString(message.MakerFeeRate), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.takerFeeRate", message.TakerFeeRate, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.TakerFeeRate) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.takerFeeRate", message.TakerFeeRate, utf8.RuneCountInString(message.TakerFeeRate), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.serviceProviderFee", message.ServiceProviderFee, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.ServiceProviderFee) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.serviceProviderFee", message.ServiceProviderFee, utf8.RuneCountInString(message.ServiceProviderFee), 100, false))
	}
	return
}

// ValidateTokenMeta runs the validations defined on TokenMeta.
func ValidateTokenMeta(message *injective_spot_exchange_rpcpb.TokenMeta) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.address", message.Address, "^0x[0-9a-fA-F]{40}$"))
	if utf8.RuneCountInString(message.Address) < 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.address", message.Address, utf8.RuneCountInString(message.Address), 42, true))
	}
	if utf8.RuneCountInString(message.Address) > 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.address", message.Address, utf8.RuneCountInString(message.Address), 42, false))
	}
	if utf8.RuneCountInString(message.Symbol) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.symbol", message.Symbol, utf8.RuneCountInString(message.Symbol), 16, false))
	}
	if message.Logo != "" {
		if utf8.RuneCountInString(message.Logo) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("message.logo", message.Logo, utf8.RuneCountInString(message.Logo), 256, false))
		}
	}
	if message.Decimals < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("message.decimals", message.Decimals, 0, true))
	}
	if message.Decimals > 18 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("message.decimals", message.Decimals, 18, false))
	}
	return
}

// ValidateMarketResponse runs the validations defined on MarketResponse.
func ValidateMarketResponse(message *injective_spot_exchange_rpcpb.MarketResponse) (err error) {
	if message.Market != nil {
		if err2 := ValidateSpotMarketInfo(message.Market); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateStreamMarketsResponse runs the validations defined on
// StreamMarketsResponse.
func ValidateStreamMarketsResponse(message *injective_spot_exchange_rpcpb.StreamMarketsResponse) (err error) {
	if message.Market == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("market", "message"))
	}
	if message.Market != nil {
		if err2 := ValidateSpotMarketInfo(message.Market); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "replace" || message.OperationType == "update" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "replace", "update", "invalidate"}))
	}
	return
}

// ValidateOrderbookResponse runs the validations defined on OrderbookResponse.
func ValidateOrderbookResponse(message *injective_spot_exchange_rpcpb.OrderbookResponse) (err error) {
	if message.Orderbook != nil {
		if err2 := ValidateSpotLimitOrderbook(message.Orderbook); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateSpotLimitOrderbook runs the validations defined on
// SpotLimitOrderbook.
func ValidateSpotLimitOrderbook(message *injective_spot_exchange_rpcpb.SpotLimitOrderbook) (err error) {
	for _, e := range message.Buys {
		if e != nil {
			if err2 := ValidatePriceLevel(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range message.Sells {
		if e != nil {
			if err2 := ValidatePriceLevel(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidatePriceLevel runs the validations defined on PriceLevel.
func ValidatePriceLevel(message *injective_spot_exchange_rpcpb.PriceLevel) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.price", message.Price, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Price) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.price", message.Price, utf8.RuneCountInString(message.Price), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.quantity", message.Quantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Quantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.quantity", message.Quantity, utf8.RuneCountInString(message.Quantity), 100, false))
	}
	return
}

// ValidateStreamOrderbookResponse runs the validations defined on
// StreamOrderbookResponse.
func ValidateStreamOrderbookResponse(message *injective_spot_exchange_rpcpb.StreamOrderbookResponse) (err error) {
	if message.Orderbook == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orderbook", "message"))
	}
	if message.Orderbook != nil {
		if err2 := ValidateSpotLimitOrderbook(message.Orderbook); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "replace" || message.OperationType == "update" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "replace", "update", "invalidate"}))
	}
	return
}

// ValidateOrdersResponse runs the validations defined on OrdersResponse.
func ValidateOrdersResponse(message *injective_spot_exchange_rpcpb.OrdersResponse) (err error) {
	for _, e := range message.Orders {
		if e != nil {
			if err2 := ValidateSpotLimitOrder(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateSpotLimitOrder runs the validations defined on SpotLimitOrder.
func ValidateSpotLimitOrder(message *injective_spot_exchange_rpcpb.SpotLimitOrder) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("message.orderHash", message.OrderHash, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.OrderHash) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, true))
	}
	if utf8.RuneCountInString(message.OrderHash) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, false))
	}
	if !(message.OrderType == "buy" || message.OrderType == "sell" || message.OrderType == "stop_buy" || message.OrderType == "stop_sell" || message.OrderType == "take_buy" || message.OrderType == "take_sell") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.orderType", message.OrderType, []interface{}{"buy", "sell", "stop_buy", "stop_sell", "take_buy", "take_sell"}))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.marketId", message.MarketId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.MarketId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, true))
	}
	if utf8.RuneCountInString(message.MarketId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.subaccountId", message.SubaccountId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.SubaccountId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, true))
	}
	if utf8.RuneCountInString(message.SubaccountId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.price", message.Price, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Price) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.price", message.Price, utf8.RuneCountInString(message.Price), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.quantity", message.Quantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Quantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.quantity", message.Quantity, utf8.RuneCountInString(message.Quantity), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.unfilledQuantity", message.UnfilledQuantity, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.UnfilledQuantity) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.unfilledQuantity", message.UnfilledQuantity, utf8.RuneCountInString(message.UnfilledQuantity), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.triggerPrice", message.TriggerPrice, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.TriggerPrice) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.triggerPrice", message.TriggerPrice, utf8.RuneCountInString(message.TriggerPrice), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.feeRecipient", message.FeeRecipient, "^inj1[0-9a-zA-Z]{38}$"))
	if utf8.RuneCountInString(message.FeeRecipient) < 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.feeRecipient", message.FeeRecipient, utf8.RuneCountInString(message.FeeRecipient), 42, true))
	}
	if utf8.RuneCountInString(message.FeeRecipient) > 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.feeRecipient", message.FeeRecipient, utf8.RuneCountInString(message.FeeRecipient), 42, false))
	}
	if !(message.State == "unfilled" || message.State == "filled" || message.State == "canceled") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.state", message.State, []interface{}{"unfilled", "filled", "canceled"}))
	}
	return
}

// ValidateStreamOrdersResponse runs the validations defined on
// StreamOrdersResponse.
func ValidateStreamOrdersResponse(message *injective_spot_exchange_rpcpb.StreamOrdersResponse) (err error) {
	if message.Order == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("order", "message"))
	}
	if message.Order != nil {
		if err2 := ValidateSpotLimitOrder(message.Order); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "replace" || message.OperationType == "update" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "replace", "update", "invalidate"}))
	}
	return
}

// ValidateTradesResponse runs the validations defined on TradesResponse.
func ValidateTradesResponse(message *injective_spot_exchange_rpcpb.TradesResponse) (err error) {
	for _, e := range message.Trades {
		if e != nil {
			if err2 := ValidateSpotTrade(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateSpotTrade runs the validations defined on SpotTrade.
func ValidateSpotTrade(message *injective_spot_exchange_rpcpb.SpotTrade) (err error) {
	if message.Price == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("price", "message"))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.orderHash", message.OrderHash, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.OrderHash) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, true))
	}
	if utf8.RuneCountInString(message.OrderHash) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.orderHash", message.OrderHash, utf8.RuneCountInString(message.OrderHash), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.subaccountId", message.SubaccountId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.SubaccountId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, true))
	}
	if utf8.RuneCountInString(message.SubaccountId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.subaccountId", message.SubaccountId, utf8.RuneCountInString(message.SubaccountId), 66, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.marketId", message.MarketId, "^0x[0-9a-fA-F]{64}$"))
	if utf8.RuneCountInString(message.MarketId) < 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, true))
	}
	if utf8.RuneCountInString(message.MarketId) > 66 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.marketId", message.MarketId, utf8.RuneCountInString(message.MarketId), 66, false))
	}
	if !(message.TradeExecutionType == "market" || message.TradeExecutionType == "limitFill" || message.TradeExecutionType == "limitMatchRestingOrder" || message.TradeExecutionType == "limitMatchNewOrder") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.tradeExecutionType", message.TradeExecutionType, []interface{}{"market", "limitFill", "limitMatchRestingOrder", "limitMatchNewOrder"}))
	}
	if !(message.TradeDirection == "buy" || message.TradeDirection == "sell") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.tradeDirection", message.TradeDirection, []interface{}{"buy", "sell"}))
	}
	if message.Price != nil {
		if err2 := ValidatePriceLevel(message.Price); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("message.fee", message.Fee, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(message.Fee) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("message.fee", message.Fee, utf8.RuneCountInString(message.Fee), 100, false))
	}
	return
}

// ValidateStreamTradesResponse runs the validations defined on
// StreamTradesResponse.
func ValidateStreamTradesResponse(message *injective_spot_exchange_rpcpb.StreamTradesResponse) (err error) {
	if message.Trade == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("trade", "message"))
	}
	if message.Trade != nil {
		if err2 := ValidateSpotTrade(message.Trade); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(message.OperationType == "insert" || message.OperationType == "invalidate") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operationType", message.OperationType, []interface{}{"insert", "invalidate"}))
	}
	return
}

// ValidateSubaccountOrdersListResponse runs the validations defined on
// SubaccountOrdersListResponse.
func ValidateSubaccountOrdersListResponse(message *injective_spot_exchange_rpcpb.SubaccountOrdersListResponse) (err error) {
	for _, e := range message.Orders {
		if e != nil {
			if err2 := ValidateSpotLimitOrder(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateSubaccountTradesListResponse runs the validations defined on
// SubaccountTradesListResponse.
func ValidateSubaccountTradesListResponse(message *injective_spot_exchange_rpcpb.SubaccountTradesListResponse) (err error) {
	for _, e := range message.Trades {
		if e != nil {
			if err2 := ValidateSpotTrade(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// svcInjectivespotexchangerpcTokenMetaToInjectiveSpotExchangeRpcpbTokenMeta
// builds a value of type *injective_spot_exchange_rpcpb.TokenMeta from a value
// of type *injectivespotexchangerpc.TokenMeta.
func svcInjectivespotexchangerpcTokenMetaToInjectiveSpotExchangeRpcpbTokenMeta(v *injectivespotexchangerpc.TokenMeta) *injective_spot_exchange_rpcpb.TokenMeta {
	if v == nil {
		return nil
	}
	res := &injective_spot_exchange_rpcpb.TokenMeta{
		Name:      v.Name,
		Address:   v.Address,
		Symbol:    v.Symbol,
		Decimals:  int32(v.Decimals),
		UpdatedAt: v.UpdatedAt,
	}
	if v.Logo != nil {
		res.Logo = *v.Logo
	}

	return res
}

// protobufInjectiveSpotExchangeRpcpbTokenMetaToInjectivespotexchangerpcTokenMeta
// builds a value of type *injectivespotexchangerpc.TokenMeta from a value of
// type *injective_spot_exchange_rpcpb.TokenMeta.
func protobufInjectiveSpotExchangeRpcpbTokenMetaToInjectivespotexchangerpcTokenMeta(v *injective_spot_exchange_rpcpb.TokenMeta) *injectivespotexchangerpc.TokenMeta {
	if v == nil {
		return nil
	}
	res := &injectivespotexchangerpc.TokenMeta{
		Name:      v.Name,
		Address:   v.Address,
		Symbol:    v.Symbol,
		Decimals:  int(v.Decimals),
		UpdatedAt: v.UpdatedAt,
	}
	if v.Logo != "" {
		res.Logo = &v.Logo
	}

	return res
}

// svcInjectivespotexchangerpcSpotMarketInfoToInjectiveSpotExchangeRpcpbSpotMarketInfo
// builds a value of type *injective_spot_exchange_rpcpb.SpotMarketInfo from a
// value of type *injectivespotexchangerpc.SpotMarketInfo.
func svcInjectivespotexchangerpcSpotMarketInfoToInjectiveSpotExchangeRpcpbSpotMarketInfo(v *injectivespotexchangerpc.SpotMarketInfo) *injective_spot_exchange_rpcpb.SpotMarketInfo {
	if v == nil {
		return nil
	}
	res := &injective_spot_exchange_rpcpb.SpotMarketInfo{
		MarketId:                 v.MarketID,
		MarketStatus:             v.MarketStatus,
		Ticker:                   v.Ticker,
		BaseDenom:                v.BaseDenom,
		QuoteDenom:               v.QuoteDenom,
		MakerFeeRate:             v.MakerFeeRate,
		TakerFeeRate:             v.TakerFeeRate,
		ServiceProviderFee:       v.ServiceProviderFee,
		MaxPriceScaleDecimals:    v.MaxPriceScaleDecimals,
		MaxQuantityScaleDecimals: v.MaxQuantityScaleDecimals,
	}
	if v.BaseTokenMeta != nil {
		res.BaseTokenMeta = svcInjectivespotexchangerpcTokenMetaToInjectiveSpotExchangeRpcpbTokenMeta(v.BaseTokenMeta)
	}
	if v.QuoteTokenMeta != nil {
		res.QuoteTokenMeta = svcInjectivespotexchangerpcTokenMetaToInjectiveSpotExchangeRpcpbTokenMeta(v.QuoteTokenMeta)
	}

	return res
}

// protobufInjectiveSpotExchangeRpcpbSpotMarketInfoToInjectivespotexchangerpcSpotMarketInfo
// builds a value of type *injectivespotexchangerpc.SpotMarketInfo from a value
// of type *injective_spot_exchange_rpcpb.SpotMarketInfo.
func protobufInjectiveSpotExchangeRpcpbSpotMarketInfoToInjectivespotexchangerpcSpotMarketInfo(v *injective_spot_exchange_rpcpb.SpotMarketInfo) *injectivespotexchangerpc.SpotMarketInfo {
	if v == nil {
		return nil
	}
	res := &injectivespotexchangerpc.SpotMarketInfo{
		MarketID:                 v.MarketId,
		MarketStatus:             v.MarketStatus,
		Ticker:                   v.Ticker,
		BaseDenom:                v.BaseDenom,
		QuoteDenom:               v.QuoteDenom,
		MakerFeeRate:             v.MakerFeeRate,
		TakerFeeRate:             v.TakerFeeRate,
		ServiceProviderFee:       v.ServiceProviderFee,
		MaxPriceScaleDecimals:    v.MaxPriceScaleDecimals,
		MaxQuantityScaleDecimals: v.MaxQuantityScaleDecimals,
	}
	if v.BaseTokenMeta != nil {
		res.BaseTokenMeta = protobufInjectiveSpotExchangeRpcpbTokenMetaToInjectivespotexchangerpcTokenMeta(v.BaseTokenMeta)
	}
	if v.QuoteTokenMeta != nil {
		res.QuoteTokenMeta = protobufInjectiveSpotExchangeRpcpbTokenMetaToInjectivespotexchangerpcTokenMeta(v.QuoteTokenMeta)
	}
	if v.MaxPriceScaleDecimals == 0 {
		res.MaxPriceScaleDecimals = 6
	}
	if v.MaxQuantityScaleDecimals == 0 {
		res.MaxQuantityScaleDecimals = 6
	}

	return res
}

// svcInjectivespotexchangerpcSpotLimitOrderbookToInjectiveSpotExchangeRpcpbSpotLimitOrderbook
// builds a value of type *injective_spot_exchange_rpcpb.SpotLimitOrderbook
// from a value of type *injectivespotexchangerpc.SpotLimitOrderbook.
func svcInjectivespotexchangerpcSpotLimitOrderbookToInjectiveSpotExchangeRpcpbSpotLimitOrderbook(v *injectivespotexchangerpc.SpotLimitOrderbook) *injective_spot_exchange_rpcpb.SpotLimitOrderbook {
	if v == nil {
		return nil
	}
	res := &injective_spot_exchange_rpcpb.SpotLimitOrderbook{}
	if v.Buys != nil {
		res.Buys = make([]*injective_spot_exchange_rpcpb.PriceLevel, len(v.Buys))
		for i, val := range v.Buys {
			res.Buys[i] = &injective_spot_exchange_rpcpb.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}
	if v.Sells != nil {
		res.Sells = make([]*injective_spot_exchange_rpcpb.PriceLevel, len(v.Sells))
		for i, val := range v.Sells {
			res.Sells[i] = &injective_spot_exchange_rpcpb.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}

	return res
}

// protobufInjectiveSpotExchangeRpcpbSpotLimitOrderbookToInjectivespotexchangerpcSpotLimitOrderbook
// builds a value of type *injectivespotexchangerpc.SpotLimitOrderbook from a
// value of type *injective_spot_exchange_rpcpb.SpotLimitOrderbook.
func protobufInjectiveSpotExchangeRpcpbSpotLimitOrderbookToInjectivespotexchangerpcSpotLimitOrderbook(v *injective_spot_exchange_rpcpb.SpotLimitOrderbook) *injectivespotexchangerpc.SpotLimitOrderbook {
	if v == nil {
		return nil
	}
	res := &injectivespotexchangerpc.SpotLimitOrderbook{}
	if v.Buys != nil {
		res.Buys = make([]*injectivespotexchangerpc.PriceLevel, len(v.Buys))
		for i, val := range v.Buys {
			res.Buys[i] = &injectivespotexchangerpc.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}
	if v.Sells != nil {
		res.Sells = make([]*injectivespotexchangerpc.PriceLevel, len(v.Sells))
		for i, val := range v.Sells {
			res.Sells[i] = &injectivespotexchangerpc.PriceLevel{
				Price:     val.Price,
				Quantity:  val.Quantity,
				Timestamp: val.Timestamp,
			}
		}
	}

	return res
}

// svcInjectivespotexchangerpcSpotLimitOrderToInjectiveSpotExchangeRpcpbSpotLimitOrder
// builds a value of type *injective_spot_exchange_rpcpb.SpotLimitOrder from a
// value of type *injectivespotexchangerpc.SpotLimitOrder.
func svcInjectivespotexchangerpcSpotLimitOrderToInjectiveSpotExchangeRpcpbSpotLimitOrder(v *injectivespotexchangerpc.SpotLimitOrder) *injective_spot_exchange_rpcpb.SpotLimitOrder {
	res := &injective_spot_exchange_rpcpb.SpotLimitOrder{
		OrderHash:        v.OrderHash,
		OrderType:        v.OrderType,
		MarketId:         v.MarketID,
		SubaccountId:     v.SubaccountID,
		Price:            v.Price,
		Quantity:         v.Quantity,
		UnfilledQuantity: v.UnfilledQuantity,
		TriggerPrice:     v.TriggerPrice,
		FeeRecipient:     v.FeeRecipient,
		State:            v.State,
		CreatedAt:        v.CreatedAt,
	}
	if v.UpdatedAt != nil {
		res.UpdatedAt = *v.UpdatedAt
	}

	return res
}

// protobufInjectiveSpotExchangeRpcpbSpotLimitOrderToInjectivespotexchangerpcSpotLimitOrder
// builds a value of type *injectivespotexchangerpc.SpotLimitOrder from a value
// of type *injective_spot_exchange_rpcpb.SpotLimitOrder.
func protobufInjectiveSpotExchangeRpcpbSpotLimitOrderToInjectivespotexchangerpcSpotLimitOrder(v *injective_spot_exchange_rpcpb.SpotLimitOrder) *injectivespotexchangerpc.SpotLimitOrder {
	res := &injectivespotexchangerpc.SpotLimitOrder{
		OrderHash:        v.OrderHash,
		OrderType:        v.OrderType,
		MarketID:         v.MarketId,
		SubaccountID:     v.SubaccountId,
		Price:            v.Price,
		Quantity:         v.Quantity,
		UnfilledQuantity: v.UnfilledQuantity,
		TriggerPrice:     v.TriggerPrice,
		FeeRecipient:     v.FeeRecipient,
		State:            v.State,
		CreatedAt:        v.CreatedAt,
	}
	if v.UpdatedAt != 0 {
		res.UpdatedAt = &v.UpdatedAt
	}

	return res
}

// svcInjectivespotexchangerpcPriceLevelToInjectiveSpotExchangeRpcpbPriceLevel
// builds a value of type *injective_spot_exchange_rpcpb.PriceLevel from a
// value of type *injectivespotexchangerpc.PriceLevel.
func svcInjectivespotexchangerpcPriceLevelToInjectiveSpotExchangeRpcpbPriceLevel(v *injectivespotexchangerpc.PriceLevel) *injective_spot_exchange_rpcpb.PriceLevel {
	res := &injective_spot_exchange_rpcpb.PriceLevel{
		Price:     v.Price,
		Quantity:  v.Quantity,
		Timestamp: v.Timestamp,
	}

	return res
}

// protobufInjectiveSpotExchangeRpcpbPriceLevelToInjectivespotexchangerpcPriceLevel
// builds a value of type *injectivespotexchangerpc.PriceLevel from a value of
// type *injective_spot_exchange_rpcpb.PriceLevel.
func protobufInjectiveSpotExchangeRpcpbPriceLevelToInjectivespotexchangerpcPriceLevel(v *injective_spot_exchange_rpcpb.PriceLevel) *injectivespotexchangerpc.PriceLevel {
	res := &injectivespotexchangerpc.PriceLevel{
		Price:     v.Price,
		Quantity:  v.Quantity,
		Timestamp: v.Timestamp,
	}

	return res
}

// svcInjectivespotexchangerpcSpotTradeToInjectiveSpotExchangeRpcpbSpotTrade
// builds a value of type *injective_spot_exchange_rpcpb.SpotTrade from a value
// of type *injectivespotexchangerpc.SpotTrade.
func svcInjectivespotexchangerpcSpotTradeToInjectiveSpotExchangeRpcpbSpotTrade(v *injectivespotexchangerpc.SpotTrade) *injective_spot_exchange_rpcpb.SpotTrade {
	res := &injective_spot_exchange_rpcpb.SpotTrade{
		OrderHash:          v.OrderHash,
		SubaccountId:       v.SubaccountID,
		MarketId:           v.MarketID,
		TradeExecutionType: v.TradeExecutionType,
		TradeDirection:     v.TradeDirection,
		Fee:                v.Fee,
		ExecutedAt:         v.ExecutedAt,
	}
	if v.Price != nil {
		res.Price = svcInjectivespotexchangerpcPriceLevelToInjectiveSpotExchangeRpcpbPriceLevel(v.Price)
	}

	return res
}

// protobufInjectiveSpotExchangeRpcpbSpotTradeToInjectivespotexchangerpcSpotTrade
// builds a value of type *injectivespotexchangerpc.SpotTrade from a value of
// type *injective_spot_exchange_rpcpb.SpotTrade.
func protobufInjectiveSpotExchangeRpcpbSpotTradeToInjectivespotexchangerpcSpotTrade(v *injective_spot_exchange_rpcpb.SpotTrade) *injectivespotexchangerpc.SpotTrade {
	res := &injectivespotexchangerpc.SpotTrade{
		OrderHash:          v.OrderHash,
		SubaccountID:       v.SubaccountId,
		MarketID:           v.MarketId,
		TradeExecutionType: v.TradeExecutionType,
		TradeDirection:     v.TradeDirection,
		Fee:                v.Fee,
		ExecutedAt:         v.ExecutedAt,
	}
	if v.Price != nil {
		res.Price = protobufInjectiveSpotExchangeRpcpbPriceLevelToInjectivespotexchangerpcPriceLevel(v.Price)
	}

	return res
}
