// Code generated by goa v3.3.1, DO NOT EDIT.
//
// InjectiveSpotExchangeRPC gRPC client encoders and decoders
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-exchange/api/design -o ../

package client

import (
	"context"

	injective_spot_exchange_rpcpb "github.com/InjectiveLabs/injective-exchange/api/gen/grpc/injective_spot_exchange_rpc/pb"
	injectivespotexchangerpc "github.com/InjectiveLabs/injective-exchange/api/gen/injective_spot_exchange_rpc"
	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildMarketsFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "markets" endpoint.
func BuildMarketsFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Markets(ctx, reqpb.(*injective_spot_exchange_rpcpb.MarketsRequest), opts...)
		}
		return grpccli.Markets(ctx, &injective_spot_exchange_rpcpb.MarketsRequest{}, opts...)
	}
}

// EncodeMarketsRequest encodes requests sent to InjectiveSpotExchangeRPC
// markets endpoint.
func EncodeMarketsRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.MarketsPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "markets", "*injectivespotexchangerpc.MarketsPayload", v)
	}
	return NewMarketsRequest(payload), nil
}

// DecodeMarketsResponse decodes responses from the InjectiveSpotExchangeRPC
// markets endpoint.
func DecodeMarketsResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_spot_exchange_rpcpb.MarketsResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "markets", "*injective_spot_exchange_rpcpb.MarketsResponse", v)
	}
	if err := ValidateMarketsResponse(message); err != nil {
		return nil, err
	}
	res := NewMarketsResult(message)
	return res, nil
}

// BuildMarketFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "market" endpoint.
func BuildMarketFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Market(ctx, reqpb.(*injective_spot_exchange_rpcpb.MarketRequest), opts...)
		}
		return grpccli.Market(ctx, &injective_spot_exchange_rpcpb.MarketRequest{}, opts...)
	}
}

// EncodeMarketRequest encodes requests sent to InjectiveSpotExchangeRPC market
// endpoint.
func EncodeMarketRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.MarketPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "market", "*injectivespotexchangerpc.MarketPayload", v)
	}
	return NewMarketRequest(payload), nil
}

// DecodeMarketResponse decodes responses from the InjectiveSpotExchangeRPC
// market endpoint.
func DecodeMarketResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_spot_exchange_rpcpb.MarketResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "market", "*injective_spot_exchange_rpcpb.MarketResponse", v)
	}
	if err := ValidateMarketResponse(message); err != nil {
		return nil, err
	}
	res := NewMarketResult(message)
	return res, nil
}

// BuildStreamMarketsFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "streamMarkets" endpoint.
func BuildStreamMarketsFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamMarkets(ctx, reqpb.(*injective_spot_exchange_rpcpb.StreamMarketsRequest), opts...)
		}
		return grpccli.StreamMarkets(ctx, &injective_spot_exchange_rpcpb.StreamMarketsRequest{}, opts...)
	}
}

// EncodeStreamMarketsRequest encodes requests sent to InjectiveSpotExchangeRPC
// streamMarkets endpoint.
func EncodeStreamMarketsRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.StreamMarketsPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "streamMarkets", "*injectivespotexchangerpc.StreamMarketsPayload", v)
	}
	return NewStreamMarketsRequest(payload), nil
}

// DecodeStreamMarketsResponse decodes responses from the
// InjectiveSpotExchangeRPC streamMarkets endpoint.
func DecodeStreamMarketsResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamMarketsClientStream{
		stream: v.(injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPC_StreamMarketsClient),
	}, nil
}

// BuildOrderbookFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "orderbook" endpoint.
func BuildOrderbookFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Orderbook(ctx, reqpb.(*injective_spot_exchange_rpcpb.OrderbookRequest), opts...)
		}
		return grpccli.Orderbook(ctx, &injective_spot_exchange_rpcpb.OrderbookRequest{}, opts...)
	}
}

// EncodeOrderbookRequest encodes requests sent to InjectiveSpotExchangeRPC
// orderbook endpoint.
func EncodeOrderbookRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.OrderbookPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "orderbook", "*injectivespotexchangerpc.OrderbookPayload", v)
	}
	return NewOrderbookRequest(payload), nil
}

// DecodeOrderbookResponse decodes responses from the InjectiveSpotExchangeRPC
// orderbook endpoint.
func DecodeOrderbookResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_spot_exchange_rpcpb.OrderbookResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "orderbook", "*injective_spot_exchange_rpcpb.OrderbookResponse", v)
	}
	if err := ValidateOrderbookResponse(message); err != nil {
		return nil, err
	}
	res := NewOrderbookResult(message)
	return res, nil
}

// BuildStreamOrderbookFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "streamOrderbook" endpoint.
func BuildStreamOrderbookFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamOrderbook(ctx, reqpb.(*injective_spot_exchange_rpcpb.StreamOrderbookRequest), opts...)
		}
		return grpccli.StreamOrderbook(ctx, &injective_spot_exchange_rpcpb.StreamOrderbookRequest{}, opts...)
	}
}

// EncodeStreamOrderbookRequest encodes requests sent to
// InjectiveSpotExchangeRPC streamOrderbook endpoint.
func EncodeStreamOrderbookRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.StreamOrderbookPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "streamOrderbook", "*injectivespotexchangerpc.StreamOrderbookPayload", v)
	}
	return NewStreamOrderbookRequest(payload), nil
}

// DecodeStreamOrderbookResponse decodes responses from the
// InjectiveSpotExchangeRPC streamOrderbook endpoint.
func DecodeStreamOrderbookResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamOrderbookClientStream{
		stream: v.(injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPC_StreamOrderbookClient),
	}, nil
}

// BuildOrdersFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "orders" endpoint.
func BuildOrdersFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Orders(ctx, reqpb.(*injective_spot_exchange_rpcpb.OrdersRequest), opts...)
		}
		return grpccli.Orders(ctx, &injective_spot_exchange_rpcpb.OrdersRequest{}, opts...)
	}
}

// EncodeOrdersRequest encodes requests sent to InjectiveSpotExchangeRPC orders
// endpoint.
func EncodeOrdersRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.SpotLimitOrdersFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "orders", "*injectivespotexchangerpc.SpotLimitOrdersFilter", v)
	}
	return NewOrdersRequest(payload), nil
}

// DecodeOrdersResponse decodes responses from the InjectiveSpotExchangeRPC
// orders endpoint.
func DecodeOrdersResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_spot_exchange_rpcpb.OrdersResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "orders", "*injective_spot_exchange_rpcpb.OrdersResponse", v)
	}
	if err := ValidateOrdersResponse(message); err != nil {
		return nil, err
	}
	res := NewOrdersResult(message)
	return res, nil
}

// BuildStreamOrdersFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "streamOrders" endpoint.
func BuildStreamOrdersFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamOrders(ctx, reqpb.(*injective_spot_exchange_rpcpb.StreamOrdersRequest), opts...)
		}
		return grpccli.StreamOrders(ctx, &injective_spot_exchange_rpcpb.StreamOrdersRequest{}, opts...)
	}
}

// EncodeStreamOrdersRequest encodes requests sent to InjectiveSpotExchangeRPC
// streamOrders endpoint.
func EncodeStreamOrdersRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.SpotLimitOrdersFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "streamOrders", "*injectivespotexchangerpc.SpotLimitOrdersFilter", v)
	}
	return NewStreamOrdersRequest(payload), nil
}

// DecodeStreamOrdersResponse decodes responses from the
// InjectiveSpotExchangeRPC streamOrders endpoint.
func DecodeStreamOrdersResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamOrdersClientStream{
		stream: v.(injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPC_StreamOrdersClient),
	}, nil
}

// BuildTradesFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "trades" endpoint.
func BuildTradesFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Trades(ctx, reqpb.(*injective_spot_exchange_rpcpb.TradesRequest), opts...)
		}
		return grpccli.Trades(ctx, &injective_spot_exchange_rpcpb.TradesRequest{}, opts...)
	}
}

// EncodeTradesRequest encodes requests sent to InjectiveSpotExchangeRPC trades
// endpoint.
func EncodeTradesRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.SpotTradesFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "trades", "*injectivespotexchangerpc.SpotTradesFilter", v)
	}
	return NewTradesRequest(payload), nil
}

// DecodeTradesResponse decodes responses from the InjectiveSpotExchangeRPC
// trades endpoint.
func DecodeTradesResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_spot_exchange_rpcpb.TradesResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "trades", "*injective_spot_exchange_rpcpb.TradesResponse", v)
	}
	if err := ValidateTradesResponse(message); err != nil {
		return nil, err
	}
	res := NewTradesResult(message)
	return res, nil
}

// BuildStreamTradesFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "streamTrades" endpoint.
func BuildStreamTradesFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamTrades(ctx, reqpb.(*injective_spot_exchange_rpcpb.StreamTradesRequest), opts...)
		}
		return grpccli.StreamTrades(ctx, &injective_spot_exchange_rpcpb.StreamTradesRequest{}, opts...)
	}
}

// EncodeStreamTradesRequest encodes requests sent to InjectiveSpotExchangeRPC
// streamTrades endpoint.
func EncodeStreamTradesRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.SpotTradesFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "streamTrades", "*injectivespotexchangerpc.SpotTradesFilter", v)
	}
	return NewStreamTradesRequest(payload), nil
}

// DecodeStreamTradesResponse decodes responses from the
// InjectiveSpotExchangeRPC streamTrades endpoint.
func DecodeStreamTradesResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamTradesClientStream{
		stream: v.(injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPC_StreamTradesClient),
	}, nil
}

// BuildSubaccountOrdersListFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "subaccountOrdersList" endpoint.
func BuildSubaccountOrdersListFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountOrdersList(ctx, reqpb.(*injective_spot_exchange_rpcpb.SubaccountOrdersListRequest), opts...)
		}
		return grpccli.SubaccountOrdersList(ctx, &injective_spot_exchange_rpcpb.SubaccountOrdersListRequest{}, opts...)
	}
}

// EncodeSubaccountOrdersListRequest encodes requests sent to
// InjectiveSpotExchangeRPC subaccountOrdersList endpoint.
func EncodeSubaccountOrdersListRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.SubaccountOrdersListPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "subaccountOrdersList", "*injectivespotexchangerpc.SubaccountOrdersListPayload", v)
	}
	return NewSubaccountOrdersListRequest(payload), nil
}

// DecodeSubaccountOrdersListResponse decodes responses from the
// InjectiveSpotExchangeRPC subaccountOrdersList endpoint.
func DecodeSubaccountOrdersListResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_spot_exchange_rpcpb.SubaccountOrdersListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "subaccountOrdersList", "*injective_spot_exchange_rpcpb.SubaccountOrdersListResponse", v)
	}
	if err := ValidateSubaccountOrdersListResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountOrdersListResult(message)
	return res, nil
}

// BuildSubaccountTradesListFunc builds the remote method to invoke for
// "InjectiveSpotExchangeRPC" service "subaccountTradesList" endpoint.
func BuildSubaccountTradesListFunc(grpccli injective_spot_exchange_rpcpb.InjectiveSpotExchangeRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountTradesList(ctx, reqpb.(*injective_spot_exchange_rpcpb.SubaccountTradesListRequest), opts...)
		}
		return grpccli.SubaccountTradesList(ctx, &injective_spot_exchange_rpcpb.SubaccountTradesListRequest{}, opts...)
	}
}

// EncodeSubaccountTradesListRequest encodes requests sent to
// InjectiveSpotExchangeRPC subaccountTradesList endpoint.
func EncodeSubaccountTradesListRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectivespotexchangerpc.SubaccountTradesListPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "subaccountTradesList", "*injectivespotexchangerpc.SubaccountTradesListPayload", v)
	}
	return NewSubaccountTradesListRequest(payload), nil
}

// DecodeSubaccountTradesListResponse decodes responses from the
// InjectiveSpotExchangeRPC subaccountTradesList endpoint.
func DecodeSubaccountTradesListResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_spot_exchange_rpcpb.SubaccountTradesListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveSpotExchangeRPC", "subaccountTradesList", "*injective_spot_exchange_rpcpb.SubaccountTradesListResponse", v)
	}
	if err := ValidateSubaccountTradesListResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountTradesListResult(message)
	return res, nil
}
