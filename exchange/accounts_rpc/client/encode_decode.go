// Code generated by goa v3.3.1, DO NOT EDIT.
//
// InjectiveAccountsRPC gRPC client encoders and decoders
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-exchange/api/design -o ../

package client

import (
	"context"

	injective_accounts_rpcpb "github.com/InjectiveLabs/injective-exchange/api/gen/grpc/injective_accounts_rpc/pb"
	injectiveaccountsrpc "github.com/InjectiveLabs/injective-exchange/api/gen/injective_accounts_rpc"
	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildSubaccountsListFunc builds the remote method to invoke for
// "InjectiveAccountsRPC" service "subaccountsList" endpoint.
func BuildSubaccountsListFunc(grpccli injective_accounts_rpcpb.InjectiveAccountsRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountsList(ctx, reqpb.(*injective_accounts_rpcpb.SubaccountsListRequest), opts...)
		}
		return grpccli.SubaccountsList(ctx, &injective_accounts_rpcpb.SubaccountsListRequest{}, opts...)
	}
}

// EncodeSubaccountsListRequest encodes requests sent to InjectiveAccountsRPC
// subaccountsList endpoint.
func EncodeSubaccountsListRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveaccountsrpc.SubaccountsListPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountsList", "*injectiveaccountsrpc.SubaccountsListPayload", v)
	}
	return NewSubaccountsListRequest(payload), nil
}

// DecodeSubaccountsListResponse decodes responses from the
// InjectiveAccountsRPC subaccountsList endpoint.
func DecodeSubaccountsListResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_accounts_rpcpb.SubaccountsListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountsList", "*injective_accounts_rpcpb.SubaccountsListResponse", v)
	}
	if err := ValidateSubaccountsListResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountsListResult(message)
	return res, nil
}

// BuildSubaccountBalancesListFunc builds the remote method to invoke for
// "InjectiveAccountsRPC" service "subaccountBalancesList" endpoint.
func BuildSubaccountBalancesListFunc(grpccli injective_accounts_rpcpb.InjectiveAccountsRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountBalancesList(ctx, reqpb.(*injective_accounts_rpcpb.SubaccountBalancesListRequest), opts...)
		}
		return grpccli.SubaccountBalancesList(ctx, &injective_accounts_rpcpb.SubaccountBalancesListRequest{}, opts...)
	}
}

// EncodeSubaccountBalancesListRequest encodes requests sent to
// InjectiveAccountsRPC subaccountBalancesList endpoint.
func EncodeSubaccountBalancesListRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveaccountsrpc.SubaccountBalanceFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountBalancesList", "*injectiveaccountsrpc.SubaccountBalanceFilter", v)
	}
	return NewSubaccountBalancesListRequest(payload), nil
}

// DecodeSubaccountBalancesListResponse decodes responses from the
// InjectiveAccountsRPC subaccountBalancesList endpoint.
func DecodeSubaccountBalancesListResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_accounts_rpcpb.SubaccountBalancesListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountBalancesList", "*injective_accounts_rpcpb.SubaccountBalancesListResponse", v)
	}
	if err := ValidateSubaccountBalancesListResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountBalancesListResult(message)
	return res, nil
}

// BuildSubaccountBalanceEndpointFunc builds the remote method to invoke for
// "InjectiveAccountsRPC" service "subaccountBalance" endpoint.
func BuildSubaccountBalanceEndpointFunc(grpccli injective_accounts_rpcpb.InjectiveAccountsRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountBalanceEndpoint(ctx, reqpb.(*injective_accounts_rpcpb.SubaccountBalanceRequest), opts...)
		}
		return grpccli.SubaccountBalanceEndpoint(ctx, &injective_accounts_rpcpb.SubaccountBalanceRequest{}, opts...)
	}
}

// EncodeSubaccountBalanceEndpointRequest encodes requests sent to
// InjectiveAccountsRPC subaccountBalance endpoint.
func EncodeSubaccountBalanceEndpointRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveaccountsrpc.SubaccountBalancePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountBalance", "*injectiveaccountsrpc.SubaccountBalancePayload", v)
	}
	return NewSubaccountBalanceRequest(payload), nil
}

// DecodeSubaccountBalanceEndpointResponse decodes responses from the
// InjectiveAccountsRPC subaccountBalance endpoint.
func DecodeSubaccountBalanceEndpointResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_accounts_rpcpb.SubaccountBalanceResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountBalance", "*injective_accounts_rpcpb.SubaccountBalanceResponse", v)
	}
	if err := ValidateSubaccountBalanceResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountBalanceResult(message)
	return res, nil
}

// BuildStreamSubaccountBalanceFunc builds the remote method to invoke for
// "InjectiveAccountsRPC" service "streamSubaccountBalance" endpoint.
func BuildStreamSubaccountBalanceFunc(grpccli injective_accounts_rpcpb.InjectiveAccountsRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.StreamSubaccountBalance(ctx, reqpb.(*injective_accounts_rpcpb.StreamSubaccountBalanceRequest), opts...)
		}
		return grpccli.StreamSubaccountBalance(ctx, &injective_accounts_rpcpb.StreamSubaccountBalanceRequest{}, opts...)
	}
}

// EncodeStreamSubaccountBalanceRequest encodes requests sent to
// InjectiveAccountsRPC streamSubaccountBalance endpoint.
func EncodeStreamSubaccountBalanceRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveaccountsrpc.SubaccountBalanceFilter)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "streamSubaccountBalance", "*injectiveaccountsrpc.SubaccountBalanceFilter", v)
	}
	return NewStreamSubaccountBalanceRequest(payload), nil
}

// DecodeStreamSubaccountBalanceResponse decodes responses from the
// InjectiveAccountsRPC streamSubaccountBalance endpoint.
func DecodeStreamSubaccountBalanceResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &StreamSubaccountBalanceClientStream{
		stream: v.(injective_accounts_rpcpb.InjectiveAccountsRPC_StreamSubaccountBalanceClient),
	}, nil
}

// BuildSubaccountHistoryFunc builds the remote method to invoke for
// "InjectiveAccountsRPC" service "subaccountHistory" endpoint.
func BuildSubaccountHistoryFunc(grpccli injective_accounts_rpcpb.InjectiveAccountsRPCClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SubaccountHistory(ctx, reqpb.(*injective_accounts_rpcpb.SubaccountHistoryRequest), opts...)
		}
		return grpccli.SubaccountHistory(ctx, &injective_accounts_rpcpb.SubaccountHistoryRequest{}, opts...)
	}
}

// EncodeSubaccountHistoryRequest encodes requests sent to InjectiveAccountsRPC
// subaccountHistory endpoint.
func EncodeSubaccountHistoryRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*injectiveaccountsrpc.SubaccountHistoryPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountHistory", "*injectiveaccountsrpc.SubaccountHistoryPayload", v)
	}
	return NewSubaccountHistoryRequest(payload), nil
}

// DecodeSubaccountHistoryResponse decodes responses from the
// InjectiveAccountsRPC subaccountHistory endpoint.
func DecodeSubaccountHistoryResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*injective_accounts_rpcpb.SubaccountHistoryResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InjectiveAccountsRPC", "subaccountHistory", "*injective_accounts_rpcpb.SubaccountHistoryResponse", v)
	}
	if err := ValidateSubaccountHistoryResponse(message); err != nil {
		return nil, err
	}
	res := NewSubaccountHistoryResult(message)
	return res, nil
}
